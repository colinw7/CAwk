CONCAT_ID=##concat##
##concat##CAwkAction.cpp
#include <CAwk.h>
#include <CPrintF.h>
#include <CFuncs.h>
#include <CCommand.h>
#include <CStrUtil.h>
#include <CReadLine.h>
#include <cstdio>

void
CAwkNullAction::
exec()
{
  std::string str = CAwkInst->getLineField(0);

  std::cout << str;

  std::cout << CAwkInst->getVariable("ORS")->getValue()->getString();
}

//-----------

void
CAwkBreakAction::
exec()
{
  CAwkInst->setBreakFlag();
}

//-----------

void
CAwkContinueAction::
exec()
{
  CAwkInst->setContinueFlag();
}

//-----------

void
CAwkNextAction::
exec()
{
  CAwkInst->setNextFlag();
}

//-----------

void
CAwkReturnAction::
exec()
{
  auto value = expression_->getValue();

  CAwkInst->setReturnValue(value);
}

void
CAwkReturnAction::
print(std::ostream &os) const
{
  os << "return";

  if (expression_)
    os << " " << *expression_;
}

//-----------

void
CAwkExitAction::
exec()
{
  CAwkInst->setExitFlag();
}

void
CAwkExitAction::
print(std::ostream &os) const
{
  os << "exit";

  if (expression_)
    os << " " << *expression_;
}

//----------

void
CAwkDeleteAction::
exec()
{
  std::string ind = expression_->getValue()->getString();

  var_->removeInd(ind);
}

void
CAwkDeleteAction::
print(std::ostream &os) const
{
  os << "delete " << *var_;

  if (expression_)
    os << "[" << *expression_ << "]";
}

//----------

CAwkIfAction::
CAwkIfAction(CAwkExpressionPtr expression, CAwkActionPtr action) :
 expression_(expression)
{
  actionList_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList_->addAction(action);
}

void
CAwkIfAction::
exec()
{
  auto value = expression_->getValue();

  if (value->getBool())
    actionList_->exec();
}

void
CAwkIfAction::
print(std::ostream &os) const
{
  os << "if (" << *expression_ << ") " << *actionList_;
}

//----------

CAwkIfElseAction::
CAwkIfElseAction(CAwkExpressionPtr expression,
                 CAwkActionPtr action1, CAwkActionPtr action2) :
 expression_(expression)
{
  actionList1_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);
  actionList2_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList1_->addAction(action1);
  actionList2_->addAction(action2);
}

void
CAwkIfElseAction::
exec()
{
  auto value = expression_->getValue();

  if (value->getBool())
    actionList1_->exec();
  else
    actionList2_->exec();
}

void
CAwkIfElseAction::
print(std::ostream &os) const
{
  os << "if (" << *expression_ << ") " <<
        *actionList1_ << " else " << *actionList2_;
}

//----------

CAwkForAction::
CAwkForAction(CAwkExpressionPtr expression1, CAwkExpressionPtr expression2,
              CAwkExpressionPtr expression3, CAwkActionPtr action) :
 expression1_(expression1), expression2_(expression2),
 expression3_(expression3)
{
  actionList_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList_->addAction(action);
}

void
CAwkForAction::
exec()
{
  (void) expression1_->execute();

  auto value = expression2_->getValue();

  while (value->getBool()) {
    actionList_->exec();

    if (CAwkInst->isBreakFlag()) {
      CAwkInst->resetBreakFlag();
      break;
    }

    if (CAwkInst->isContinueFlag())
      CAwkInst->resetContinueFlag();

    if (CAwkInst->isExitFlag())
      return;

    //----

    (void) expression3_->execute();

    value = expression2_->getValue();
  }
}

void
CAwkForAction::
print(std::ostream &os) const
{
  os << "for (" << *expression1_ << "; " << *expression2_ << "; " <<
        *expression3_ << ") " << *actionList_;
}

//----------

CAwkForInAction::
CAwkForInAction(CAwkVariableRefPtr var1, CAwkVariableRefPtr var2,
                CAwkActionPtr action) :
 var1_(var1), var2_(var2)
{
  actionList_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList_->addAction(action);
}

void
CAwkForInAction::
exec()
{
  StringVectorT indices = var2_->getIndices();

  auto p1 = indices.begin();
  auto p2 = indices.end  ();

  for ( ; p1 != p2; ++p1) {
    var1_->setValue(CAwkValue::create(*p1));

    //----

    actionList_->exec();

    if (CAwkInst->isBreakFlag()) {
      CAwkInst->resetBreakFlag();
      break;
    }

    if (CAwkInst->isContinueFlag())
      CAwkInst->resetContinueFlag();

    if (CAwkInst->isExitFlag())
      return;
  }
}

void
CAwkForInAction::
print(std::ostream &os) const
{
  os << "for (" << *var1_ << " in " << *var2_ << ") " << *actionList_;
}

//----------

CAwkWhileAction::
CAwkWhileAction(CAwkExpressionPtr expression, CAwkActionPtr action) :
 expression_(expression)
{
  actionList_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList_->addAction(action);
}

void
CAwkWhileAction::
exec()
{
  auto value = expression_->getValue();

  while (value->getBool()) {
    actionList_->exec();

    if (CAwkInst->isBreakFlag()) {
      CAwkInst->resetBreakFlag();
      break;
    }

    if (CAwkInst->isContinueFlag())
      CAwkInst->resetContinueFlag();

    if (CAwkInst->isExitFlag())
      return;

    //----

    value = expression_->getValue();
  }
}

void
CAwkWhileAction::
print(std::ostream &os) const
{
  os << "while (" << *expression_ << ") " << *actionList_;
}

//----------

CAwkDoWhileAction::
CAwkDoWhileAction(CAwkActionPtr action, CAwkExpressionPtr expression) :
 expression_(expression)
{
  actionList_ = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

  actionList_->addAction(action);
}

void
CAwkDoWhileAction::
exec()
{
  CAwkValuePtr value;

  do {
    actionList_->exec();

    if (CAwkInst->isBreakFlag()) {
      CAwkInst->resetBreakFlag();
      break;
    }

    if (CAwkInst->isContinueFlag())
      CAwkInst->resetContinueFlag();

    if (CAwkInst->isExitFlag())
      return;

    //----

    value = expression_->getValue();
  }
  while (value->getBool());
}

void
CAwkDoWhileAction::
print(std::ostream &os) const
{
  os << "do " << *actionList_ << " while (" << *expression_ << ")";
}

//-----------

void
CAwkActionListAction::
exec()
{
  actionList_->exec();
}

void
CAwkActionListAction::
print(std::ostream &os) const
{
  actionList_->print(os);
}

//-----------

void
CAwkExpressionAction::
exec()
{
  /*CAwkValuePtr value =*/ expression_->execute();

  //std::cout << *value << std::endl;
}

void
CAwkExpressionAction::
print(std::ostream &os) const
{
  os << *expression_;
}

//-----------

void
CAwkCloseAction::
exec()
{
  std::string str = expression_->getValue()->getString();

  CAwkInst->closeFile(str);
  CAwkInst->closePipe(str);
}

void
CAwkCloseAction::
print(std::ostream &os) const
{
  os << "close(" << *expression_ << ")";
}

//-----------

void
CAwkGetLineAction::
exec()
{
  std::string line;

  if (file_) {
    std::string str;

    file_->read(line);
  }
  else {
    CReadLine readline;

    line = readline.readLine();
  }

  var_->setValue(CAwkValue::create(line));
}

void
CAwkGetLineAction::
print(std::ostream &os) const
{
  os << "getline";

  if (var_)
    os << " " << *var_;

  if (file_)
    os << " " << *file_;
}

//-----------

void
CAwkPrintAction::
exec()
{
  std::string str;

  if (expressionList_.empty())
    str = CAwkInst->getLineField(0);
  else {
    auto p1 = expressionList_.begin();
    auto p2 = expressionList_.end  ();

    for (int i = 0; p1 != p2; ++p1, ++i) {
      if (i > 0)
        str += CAwkInst->getVariable("OFS")->getValue()->getString();

      auto value = (*p1)->getValue();

      if (value)
        str += value->getString();
    }
  }

  str += CAwkInst->getVariable("ORS")->getValue()->getString();

  if (file_)
    file_->write(str);
  else
    std::cout << str;
}

void
CAwkPrintAction::
print(std::ostream &os) const
{
  os << "print";

  if (! expressionList_.empty()) {
    os << " ";

    for_each(expressionList_.begin(), expressionList_.end(),
             CPrintSeparated<CAwkExpressionPtr>(os));
  }

  if (file_)
    os << *file_;
}

//-----------

void
CAwkPrintFAction::
exec()
{
  if (expressionList_.empty())
    return;

  auto p1 = expressionList_.begin();
  auto p2 = expressionList_.end  ();

  auto value = (*p1)->getValue();

  ++p1;

  if (! value)
    return;

  class PrintF : public CPrintF {
   private:
    mutable CAwkExpressionList::iterator p1_;
    mutable CAwkExpressionList::iterator p2_;

   public:
    PrintF(const std::string &format, CAwkExpressionList::iterator p1,
           CAwkExpressionList::iterator p2) :
     CPrintF(format), p1_(p1), p2_(p2) {
    }

    int         getInt     () const { return getValue()->getInteger(); }
    long        getLong    () const { return getValue()->getInteger(); }
    long        getLongLong() const { return getValue()->getInteger(); }
    double      getDouble  () const { return getValue()->getReal   (); }
    std::string getString  () const { return getValue()->getString (); }

    CAwkValuePtr getValue() const {
      CAwkValuePtr value;

      if (p1_ != p2_) {
        value = (*p1_)->getValue();

        ++p1_;
      }
      else
        value = CAwkValue::create("");

      return value;
    }
  };

  PrintF printf(value->getString(), p1, p2);

  std::string str = printf.format();

  if (file_)
    file_->write(str);
  else
    std::cout << str;
}

void
CAwkPrintFAction::
print(std::ostream &os) const
{
  os << "printf ";

  for_each(expressionList_.begin(), expressionList_.end(),
           CPrintSeparated<CAwkExpressionPtr>(os));

  if (file_)
    os << *file_;
}

//-----------

void
CAwkSystemAction::
exec()
{
  auto value = expr_->getValue();

  (void) system(value->getString().c_str());

  //std::cout << *value << std::endl;
}

void
CAwkSystemAction::
print(std::ostream &os) const
{
  os << "system(" << *expr_ << ")";
}

//-----------

void
CAwkActionList::
addAction(CAwkActionPtr action)
{
  actionList_.push_back(action);
}

void
CAwkActionList::
exec()
{
  // TODO: stack of action lists
  auto p1 = actionList_.begin();
  auto p2 = actionList_.end  ();

  for ( ; p1 != p2; ++p1) {
    if      (CAwkInst->isBreakFlag()) {
      if (type_ == Type::PROGRAM || type_ == Type::ROUTINE)
        CAwkInst->error("break not in iteration");

      if (type_ == Type::SIMPLE || type_ == Type::ITERATION)
        break;
    }
    else if (CAwkInst->isContinueFlag()) {
      if (type_ == Type::PROGRAM || type_ == Type::ROUTINE)
        CAwkInst->error("continue not in iteration");

      if (type_ == Type::SIMPLE)
        break;
    }
    else if (CAwkInst->isNextFlag())
      break;
    else if (CAwkInst->isReturnFlag())
      break;
    else if (CAwkInst->isExitFlag())
      break;

    (*p1)->exec();
  }

  if (CAwkInst->isBreakFlag()) {
    if (type_ == Type::PROGRAM || type_ == Type::ROUTINE)
      CAwkInst->error("break not in iteration");

    if (type_ == Type::ITERATION)
      CAwkInst->resetBreakFlag();
  }
  else if (CAwkInst->isContinueFlag()) {
    if (type_ == Type::PROGRAM || type_ == Type::ROUTINE)
      CAwkInst->error("continue not in iteration");

    if (type_ == Type::ITERATION)
      CAwkInst->resetContinueFlag();
  }
  else if (CAwkInst->isNextFlag()) {
    if (type_ == Type::PROGRAM)
      CAwkInst->resetNextFlag();
  }
  else if (CAwkInst->isReturnFlag()) {
    if (type_ == Type::PROGRAM || type_ == Type::ROUTINE)
      CAwkInst->resetReturnFlag();
  }
}

void
CAwkActionList::
print(std::ostream &os) const
{
  for_each(actionList_.begin(), actionList_.end(),
           CPrintSeparated<CAwkActionPtr>(os, ";"));
}

//-----------

CAwkActionBlock::
CAwkActionBlock(CAwkActionListPtr actionList) :
 actionList_(actionList)
{
}

CAwkVariablePtr
CAwkActionBlock::
getVariable(const std::string &name) const
{
  return variableMgr_.getVariable(name);
}

CAwkVariablePtr
CAwkActionBlock::
addVariable(const std::string &name)
{
  auto variable = CAwkVariable::create(name, "");

  variableMgr_.addVariable(variable);

  return variable;
}

void
CAwkActionBlock::
exec()
{
  actionList_->exec();
}

void
CAwkActionBlock::
print(std::ostream &os) const
{
  os << "vars {";

  variableMgr_.print(os);

  os << "} {";

  actionList_->print(os);

  os << "}";
}

//-----------

bool
CAwkPatternAction::
isBegin() const
{
  return (pattern_.canCast<CAwkBeginPattern>());
}

bool
CAwkPatternAction::
isEnd() const
{
  return (pattern_.canCast<CAwkEndPattern>());
}

void
CAwkPatternAction::
exec()
{
  if (pattern_->exec())
    actionList_->exec();
}

void
CAwkPatternAction::
print(std::ostream &os) const
{
  os << *pattern_ << " { ";

  actionList_->print(os);

  os << " }";
}

//---------------

CAwkFileMgr::
CAwkFileMgr()
{
}

void
CAwkFileMgr::
init()
{
  term();
}

void
CAwkFileMgr::
term()
{
  delete stdInFile_ ; stdInFile_  = nullptr;
  delete stdOutFile_; stdOutFile_ = nullptr;
  delete stdErrFile_; stdErrFile_ = nullptr;

  for (const auto &file : files_)
    delete file;

  files_.clear();
}

CFile *
CAwkFileMgr::
getFile(FILE *file)
{
  if      (file == stdin) {
    if (! stdInFile_)
      stdInFile_ = new CFile(stdin);

    return stdInFile_;
  }
  else if (file == stdout) {
    if (! stdOutFile_)
      stdOutFile_ = new CFile(stdout);

    return stdOutFile_;
  }
  else if (file == stderr) {
    if (! stdErrFile_)
      stdErrFile_ = new CFile(stderr);

    return stdErrFile_;
  }
  else
    assert(false);
}

CFile *
CAwkFileMgr::
getFile(const std::string &fileName, CFileBase::Mode mode)
{
  auto *file = new CFile(fileName);

  std::string path = file->getPath();

  auto pf = files_.begin();

  for ( ; pf != files_.end(); ++pf)
    if ((*pf)->getPath() == path)
      break;

  if (pf != files_.end()) {
    delete file;

    file = *pf;

    auto mode1 = file->getOpenMode();

    if (mode != mode1)
      file->open(mode);
  }
  else {
    files_.push_back(file);

    file->open(mode);
  }

  return file;
}

bool
CAwkFileMgr::
closeFile(const std::string &fileName)
{
  CFile file(fileName);

  std::string path = file.getPath();

  for (auto pf = files_.begin(); pf != files_.end(); ++pf) {
    if ((*pf)->getPath() == path) {
      files_.erase(pf);
      return true;
    }
  }

  return false;
}

//--------------

CAwkPipeMgr::
~CAwkPipeMgr()
{
  term();
}

void
CAwkPipeMgr::
init()
{
  term();
}

void
CAwkPipeMgr::
term()
{
  auto p1 = pipes_.begin();
  auto p2 = pipes_.end  ();

  for ( ; p1 != p2; ++p1)
    delete *p1;

  pipes_.clear();
}

CAwkPipe *
CAwkPipeMgr::
getPipe(const std::string &cmdName, CAwkPipe::Type type)
{
  auto p1 = pipes_.begin();
  auto p2 = pipes_.end  ();

  for ( ; p1 != p2; ++p1)
    if ((*p1)->getCmdName() == cmdName)
      break;

  if (p1 != p2) {
    if ((*p1)->getType() == type)
      return *p1;

    pipes_.erase(p1);
  }

  auto *pipe = new CAwkPipe(cmdName, type);

  pipes_.push_back(pipe);

  return pipe;
}

bool
CAwkPipeMgr::
closePipe(const std::string &cmdName)
{
  auto p1 = pipes_.begin();
  auto p2 = pipes_.end  ();

  for ( ; p1 != p2; ++p1) {
    if ((*p1)->getCmdName() == cmdName) {
      (*p1)->close();
      pipes_.erase(p1);
      return true;
    }
  }

  return false;
}

CAwkPipe::
CAwkPipe(const std::string &cmdName, Type type) :
 cmdName_(cmdName), type_(type), opened_(true)
{
}

CAwkPipe::
~CAwkPipe()
{
  if (opened_)
    close();
}

void
CAwkPipe::
close()
{
  std::vector<std::string> args;

  args.push_back("-c");
  args.push_back(cmdName_);

  CCommand command("sh", "/bin/sh", args);

  std::string res;

  if      (type_ == Type::INPUT)
    command.addStringDest(*output_);
  else if (type_ == Type::OUTPUT) {
    command.addStringSrc (input_);
    command.addStringDest(res);
  }

  command.start();

  command.wait();

  if (type_ == Type::OUTPUT)
    std::cout << res;

  opened_ = false;
}

//--------------

bool
CAwkIFile::
read(std::string &str) const
{
  if      (type_ == Type::READ_FILE) {
    auto *file = getFile();

    char buffer[256];

    size_t numRead = 0;

    while (file->read((uchar *) buffer, 255, &numRead)) {
      buffer[numRead] = '\0';

      str += buffer;
    }

    return (str.size() > 0);
  }
  else if (type_ == Type::PIPE_COMMAND) {
    std::string cmdStr = file_->getValue()->getString();

    auto *pipe = CAwkInst->getPipe(cmdStr, CAwkPipe::Type::INPUT);

    pipe->setOutput(&str);

    CAwkInst->closePipe(cmdStr);

    return (str.size() > 0);
  }
  else
    assert(false);
}

CFile *
CAwkIFile::
getFile() const
{
  if (file_) {
    std::string fileName = file_->getValue()->getString();

    return CAwkInst->getFile(fileName, CFileBase::Mode::READ);
  }
  else
    return CAwkInst->getFile(stdin);
}

void
CAwkIFile::
print(std::ostream &os) const
{
  if (type_ == Type::READ_FILE)
    os << "<" << *file_;
  else
    os << "|" << *file_;
}

void
CAwkOFile::
write(const std::string &str)
{
  if      (type_ == Type::WRITE_FILE || type_ == Type::APPEND_FILE) {
    auto *file = getFile();

    file->write(str);
  }
  else if (type_ == Type::PIPE_COMMAND) {
    std::string cmdStr = expression_->getValue()->getString();

    auto *pipe = CAwkInst->getPipe(cmdStr, CAwkPipe::Type::OUTPUT);

    pipe->addInput(str);
  }
  else
    assert(false);
}

CFile *
CAwkOFile::
getFile() const
{
  if (expression_) {
    std::string fileName = expression_->getValue()->getString();

    if      (type_ == Type::WRITE_FILE)
      return CAwkInst->getFile(fileName, CFileBase::Mode::APPEND);
    else if (type_ == Type::APPEND_FILE)
      return CAwkInst->getFile(fileName, CFileBase::Mode::WRITE);
    else
      assert(false);
  }
  else
    return CAwkInst->getFile(stdout);
}

void
CAwkOFile::
print(std::ostream &os) const
{
  if      (type_ == Type::WRITE_FILE)
    os << ">" << *expression_;
  else if (type_ == Type::APPEND_FILE)
    os << ">>" << *expression_;
  else if (type_ == Type::PIPE_COMMAND)
    os << "|" << *expression_;
}
##concat##CAwk.cpp
#include <CAwk.h>
#include <CStrParse.h>
#include <CStrUtil.h>
#include <CFuncs.h>
#include <CFile.h>
#include <cstdio>
#include <cstring>

CAwk *
CAwk::
getInstance()
{
  static CAwk *instance;

  if (! instance)
    instance = new CAwk;

  return instance;
}

CAwk::
CAwk()
{
  parser_ = std::make_unique<CStrParse>();
}

void
CAwk::
init(const StringVectorT &args)
{
  addStdVariables();
  addStdFunctions();

  uint argc = args.size();

  getVariable("ARGC")->setValue(CAwkValue::create(int(argc)));

  for (uint i = 0; i < argc; ++i)
    getVariable("ARGV")->setIndValue(CStrUtil::toString(i), CAwkValue::create(args[i]));
}

bool
CAwk::
parseFile(const std::string &fileName)
{
  if (! CFile::exists(fileName) || ! CFile::isRegular(fileName)) {
    error("Invalid file '" + fileName + "'");
    return false;
  }

  bool rc = true;

  file_name_ = fileName;
  line_num_  = 0;

  input_file_ = std::make_unique<CFile>(fileName);

  std::string line;

  while (readLine(line)) {
    line = CStrUtil::stripSpaces(line);

    if (line == "")
      continue;

    if (! (rc = parseLine(line)))
      break;

    if (getDebug())
      std::cout << *this << std::endl;
  }

  input_file_ = nullptr;

  return rc;
}

bool
CAwk::
parseLine(const std::string &str)
{
  if (getDebug())
    std::cout << str << std::endl;

  parseInit(str);

  if (! parseProgram())
    return false;

  if (getDebug())
    std::cout << *this << std::endl;

  return true;
}

bool
CAwk::
parseInit(const std::string &str)
{
  parser_->setString(str);

  return true;
}

void
CAwk::
addStdVariables()
{
  variableMgr_.addVariable(CAwkARGCVariable    ::create());
  variableMgr_.addVariable(CAwkARGVVariable    ::create());
  variableMgr_.addVariable(CAwkFILENAMEVariable::create());
  variableMgr_.addVariable(CAwkFNRVariable     ::create());
  variableMgr_.addVariable(CAwkFSVariable      ::create());
  variableMgr_.addVariable(CAwkNFVariable      ::create());
  variableMgr_.addVariable(CAwkNRVariable      ::create());
  variableMgr_.addVariable(CAwkOFMTVariable    ::create());
  variableMgr_.addVariable(CAwkOFSVariable     ::create());
  variableMgr_.addVariable(CAwkORSVariable     ::create());
  variableMgr_.addVariable(CAwkRLENGTHVariable ::create());
  variableMgr_.addVariable(CAwkRSVariable      ::create());
  variableMgr_.addVariable(CAwkRSTARTVariable  ::create());
  variableMgr_.addVariable(CAwkSUBSEPVariable  ::create());
}

void
CAwk::
addStdFunctions()
{
  functionMgr_.addFunction(CAwkGsubFunction   ::create(this));
  functionMgr_.addFunction(CAwkIndexFunction  ::create(this));
  functionMgr_.addFunction(CAwkLengthFunction ::create(this));
  functionMgr_.addFunction(CAwkMatchFunction  ::create(this));
  functionMgr_.addFunction(CAwkSplitFunction  ::create(this));
  functionMgr_.addFunction(CAwkSprintfFunction::create(this));
  functionMgr_.addFunction(CAwkSubFunction    ::create(this));
  functionMgr_.addFunction(CAwkSubstrFunction ::create(this));

  functionMgr_.addFunction(CAwkAtan2Function  ::create(this));
  functionMgr_.addFunction(CAwkCosFunction    ::create(this));
  functionMgr_.addFunction(CAwkExpFunction    ::create(this));
  functionMgr_.addFunction(CAwkIntFunction    ::create(this));
  functionMgr_.addFunction(CAwkLogFunction    ::create(this));
  functionMgr_.addFunction(CAwkRandFunction   ::create(this));
  functionMgr_.addFunction(CAwkSinFunction    ::create(this));
  functionMgr_.addFunction(CAwkSqrtFunction   ::create(this));
  functionMgr_.addFunction(CAwkSrandFunction  ::create(this));
}

bool
CAwk::
parseProgram()
{
  // function <funcname> ( <varname_list> ) { <statement_list> }
  if (parser_->isWord("function")) {
    CAwkFunctionPtr function;

    if (! parseFunction(&function))
      return false;

    addFunction(function);
  }
  else {
    CAwkPatternPtr pattern;

    if (! parsePattern(&pattern))
      return false;

    parser_->skipSpace();

    auto actionList = CAwkActionList::create(CAwkActionList::Type::PROGRAM);

    if (parser_->isChar('{')) {
      if (! parseStatementList(&actionList))
        return false;
    }
    else {
      auto action = CAwkNullAction::create();

      actionList->addAction(action);
    }

    auto patternAction = CAwkPatternAction::create(pattern, actionList);

    addPatternAction(patternAction);
  }

  parser_->skipSpace();

  return parser_->eof();
}

void
CAwk::
print(std::ostream &os) const
{
  for_each(patternActionList_.begin(), patternActionList_.end(),
           CPrintSeparated<CAwkPatternActionPtr>(os));
}

bool
CAwk::
process()
{
  fileMgr_.init();
  pipeMgr_.init();

  uint num_begin = 0;
  uint num_body  = 0;
  uint num_end   = 0;

  // begin
  {
    auto p1 = patternActionList_.begin();
    auto p2 = patternActionList_.end  ();

    for ( ; p1 != p2; ++p1) {
      if      ((*p1)->isBegin()) {
        (*p1)->exec();

        ++num_begin;
      }
      else if ((*p1)->isEnd())
        ++num_end;
      else
        ++num_body;
    }
  }

  if (num_body != 0 || num_end != 0) {
    // body
    StringVectorT indices = getVariable("ARGV")->getIndices();

    if (indices.size() > 1) {
      auto p1 = indices.begin();
      auto p2 = indices.end  ();

      ++p1;

      for ( ; p1 != p2; ++p1) {
        std::string fileName = getVariable("ARGV")->getIndValue(*p1)->getString();

        (void) execFile(fileName);
      }
    }
    else
      (void) execFile("-");
  }

  // end
  {
    auto p1 = patternActionList_.begin();
    auto p2 = patternActionList_.end  ();

    for ( ; p1 != p2; ++p1) {
      if (! (*p1)->isEnd())
        continue;

      (*p1)->exec();
    }
  }

  // cleanup
  fileMgr_.term();
  pipeMgr_.term();

  return true;
}

bool
CAwk::
execFile(const std::string &fileName)
{
  FileP file;

  if (fileName == "-") // stdin
    file = std::make_unique<CFile>(stdin);
  else {
    if (! CFile::exists(fileName) || ! CFile::isRegular(fileName)) {
      error("Invalid file '" + fileName + "'");
      return false;
    }

    file = std::make_unique<CFile>(fileName);
  }

  getVariable("FILENAME")->getValue()->setString(fileName);

  std::string line;

  while (file->readLine(line)) {
    setLine(line);

    auto p1 = patternActionList_.begin();
    auto p2 = patternActionList_.end  ();

    for ( ; p1 != p2; ++p1) {
      if ((*p1)->isBegin() || (*p1)->isEnd())
        continue;

      (*p1)->exec();

      if (isNextFlag()) {
        resetNextFlag();
        break;
      }
    }
  }

  return true;
}

void
CAwk::
setLine(const std::string &line)
{
  line_ = line;

  setLineFields();

  getVariable("FNR")->getValue()->setInteger(
    getVariable("FNR")->getValue()->getInteger() + 1);

  getVariable("NR")->getValue()->setInteger(
    getVariable("NR")->getValue()->getInteger() + 1);
}

const std::string &
CAwk::
getLineField(uint pos) const
{
  static std::string null_str;

  if (pos == 0)
    return line_;

  if (! lineFields_) {
    auto *th = const_cast<CAwk *>(this);

    th->setLineFields();
  }

  if (pos <= lineFields_.getValue().size())
    return (lineFields_.getValue())[pos - 1];
  else
    return null_str;
}

void
CAwk::
setLineField(uint pos, const std::string &value)
{
  if (pos == 0) {
    line_ = value;

    setLineFields();

    return;
  }

  if (! lineFields_)
    setLineFields();

  StringVectorT &fields = lineFields_.getValue();

  if (pos > fields.size()) {
    while (pos > fields.size())
      fields.push_back("");

    getVariable("NF")->getValue()->setInteger(
      lineFields_.getValue().size());
  }

  fields[pos - 1] = value;

  line_ = "";

  auto p1 = fields.begin();
  auto p2 = fields.end  ();

  for (int i = 0; p1 != p2; ++p1, ++i) {
    if (i > 0)
      line_ += getVariable("OFS")->getValue()->getString();

    line_ += *p1;
  }
}

void
CAwk::
setLineFields()
{
  StringVectorT fields;

  std::string fs = getVariable("FS")->getValue()->getString();

  if (fs == " ")
    fs = " \t";

  CStrUtil::addFields(line_, fields, fs, /*skipEmpty*/true);

  lineFields_.setValue(fields);

  getVariable("NF")->getValue()->setInteger(
    lineFields_.getValue().size());
}

CAwkValuePtr
CAwk::
getReturnValue() const
{
  if (currentBlock_)
    return currentBlock_->getReturnValue();
  else
    return returnValue_;
}

void
CAwk::
setReturnValue(CAwkValuePtr returnValue)
{
  if (currentBlock_)
    currentBlock_->setReturnValue(returnValue);
  else
    returnValue_ = returnValue;
}

// function <funcname> ( <varname_list> ) { <statement_list> }
bool
CAwk::
parseFunction(CAwkFunctionPtr *function)
{
  // skip 'function'
  parser_->skipNonSpace();

  parser_->skipSpace();

  // get function name
  std::string name;

  if (! parseFuncName(name))
    return false;

  parser_->skipSpace();

  // read argument list
  if (! parser_->isChar('(')) {
    error("Expected '('");
    return false;
  }

  parser_->skipChar();

  StringVectorT args;

  if (! parseVarNameList(args))
    return false;

  parser_->skipSpace();

  if (! parser_->isChar(')')) {
    error("Expected ')'");
    return false;
  }

  parser_->skipChar();

  // read function body
  auto actionList = CAwkActionList::create(CAwkActionList::Type::ROUTINE);

  if (! parseStatementList(&actionList))
    return false;

  *function = CAwkParseFunction::create(this, name, args, actionList);

  return true;
}

// <funcname>
bool
CAwk::
parseFuncName(std::string &name)
{
  return parseIdentifier(name);
}

bool
CAwk::
parseVarNameList(StringVectorT &args)
{
  if (parser_->isChar(')'))
    return true;

  std::string arg;

  if (! parseIdentifier(arg))
    return false;

  args.push_back(arg);

  parser_->skipSpace();

  while (parser_->isChar(',')) {
    parser_->skipChar();

    arg = "";

    if (! parseIdentifier(arg))
      return false;

    args.push_back(arg);

    parser_->skipSpace();
  }

  return true;
}

bool
CAwk::
parsePattern(CAwkPatternPtr *pattern)
{
  parser_->skipSpace();

  if      (parser_->isChar('{')) {
    *pattern = CAwkNullPattern::create();
  }
  else if (parser_->isChar('/')) {
    std::string regexp;

    if (! parseRegularExpression(regexp))
      return false;

    *pattern = CAwkRegExpPattern::create(regexp);
  }
  else if (parser_->isChar('!')) {
    parser_->skipChar();

    CAwkPatternPtr pattern1;

    if (! parsePattern(&pattern1))
      return false;

    *pattern = CAwkNegatePattern::create(pattern1);
  }
  // ( <pattern> )
  else if (parser_->isChar('(')) {
    parser_->skipChar();

    CAwkPatternPtr pattern1;

    if (! parsePattern(&pattern1))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    *pattern = pattern1;
  }
  else if (parser_->isWord("BEGIN")) {
    parser_->skipChars(5);

    *pattern = CAwkBeginPattern::create();
  }
  else if (parser_->isWord("END")) {
    parser_->skipChars(3);

    *pattern = CAwkEndPattern::create();
  }
  else {
    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    *pattern = CAwkExpressionPattern::create(expression);
  }

  parser_->skipSpace();

  if      (parser_->isChar('|')) {
    auto pattern1 = *pattern;

    parser_->skipChar();

    if (! parser_->isChar('|')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    CAwkPatternPtr pattern2;

    if (! parsePattern(&pattern2))
      return false;

    *pattern = CAwkCompositeOrPattern::create(pattern1, pattern2);
  }
  else if (parser_->isChar('&')) {
    auto pattern1 = *pattern;

    parser_->skipChar();

    if (! parser_->isChar('&')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    CAwkPatternPtr pattern2;

    if (! parsePattern(&pattern2))
      return false;

    *pattern = CAwkCompositeAndPattern::create(pattern1, pattern2);
  }
  else if (parser_->isChar(',')) {
    auto pattern1 = *pattern;

    parser_->skipChar();

    CAwkPatternPtr pattern2;

    if (! parsePattern(&pattern2))
      return false;

    *pattern = CAwkRangePattern::create(pattern1, pattern2);
  }

  return true;
}

// <statement>
// <statement_list> <statement>
bool
CAwk::
parseStatementList(CAwkActionListPtr *actionList)
{
  CAwkActionPtr action;

  parser_->skipSpace();

  if (parser_->isChar('{')) {
    parser_->skipChar();

    if (isNewLine())
      parser_->skipChar();

    while (true) {
      if (! parseStatement(&action))
        return false;

      (*actionList)->addAction(action);

      parser_->skipSpace();

      if (parser_->isChar(';')) {
        parser_->skipChar();
        continue;
      }

      if (isNewLine()) {
        parser_->skipChar();

        parser_->skipSpace();

        if (! parser_->isChar('}'))
          continue;
      }

      break;
    }

    parser_->skipSpace();

    if (! parser_->isChar('}')) {
      error("Expected '}'");
      return false;
    }

    parser_->skipChar();
  }
  else {
    if (! parseStatement(&action))
      return false;

    (*actionList)->addAction(action);
  }

  return true;
}

bool
CAwk::
parseStatement(CAwkActionPtr *action)
{
  parser_->skipSpace();

  if      (parser_->isChar('}'))
    return false;

  //-------

  // break
  if      (parser_->isWord("break")) {
    parser_->skipChars(5);

    *action = CAwkBreakAction::create();
  }
  // continue
  else if (parser_->isWord("continue")) {
    parser_->skipChars(8);

    *action = CAwkContinueAction::create();
  }
  // do <statement> while ( <pattern> )
  else if (parser_->isWord("do")) {
    parser_->skipChars(2);

    CAwkActionPtr action1;

    if (! parseStatement(&action1))
      return false;

    parser_->skipSpace();

    if (! parser_->isWord("while")) {
      error("Expected 'while'");
      return false;
    }

    parser_->skipChars(5);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    *action = CAwkDoWhileAction::create(action1, expression);
  }
  // exit <pattern>
  // exit
  else if (parser_->isWord("exit")) {
    parser_->skipChars(4);

    CAwkExpressionPtr expression;

    (void) parseExpression(&expression);

    *action = CAwkExitAction::create(expression);
  }
  // for
  else if (parser_->isWord("for")) {
    parser_->skipChars(3);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    // try var 'in' var_array
    int save_pos = parser_->getPos();

    CAwkVariableRefPtr var1;

    if (parseVariable(&var1)) {
      parser_->skipSpace();

      if (parser_->isWord("in")) {
        parser_->skipChars(2);

        CAwkVariableRefPtr var2;

        if (parseVariable(&var2)) {
          parser_->skipSpace();

          if (parser_->isChar(')')) {
            parser_->skipChar();

            if (isNewLine())
              parser_->skipChar();

            CAwkActionPtr action1;

            if (! parseStatement(&action1))
              return false;

            *action = CAwkForInAction::create(var1, var2, action1);

            return true;
          }
        }
      }
    }

    parser_->setPos(save_pos);

    //-----

    CAwkExpressionPtr expression1;

    if (! parseExpression(&expression1))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(';')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression2;

    if (! parseExpression(&expression2))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(';')) {
      error("Expected ';'");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression3;

    if (! parseExpression(&expression3))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    if (isNewLine())
      parser_->skipChar();

    CAwkActionPtr action1;

    if (! parseStatement(&action1))
      return false;

    *action = CAwkForAction::create(expression1, expression2, expression3, action1);
  }
  // if <statement> else <statement>
  // if <statement>
  else if (parser_->isWord("if")) {
    parser_->skipChars(2);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    if (isNewLine())
      parser_->skipChar();

    CAwkActionPtr action1;

    if (! parseStatement(&action1))
      return false;

    int save_pos = parser_->getPos();

    if (isNewLine())
      parser_->skipChar();

    if (parser_->isWord("else")) {
      parser_->skipChars(4);

      if (isNewLine())
        parser_->skipChar();

      CAwkActionPtr action2;

      if (! parseStatement(&action2))
        return false;

      *action = CAwkIfElseAction::create(expression, action1, action2);
    }
    else {
      parser_->setPos(save_pos);

      *action = CAwkIfAction::create(expression, action1);
    }
  }
  // { <statement_list> }
  else if (parser_->isChar('{')) {
    auto actionList = CAwkActionList::create(CAwkActionList::Type::SIMPLE);

    if (! parseStatementList(&actionList))
      return false;

    *action = CAwkActionListAction::create(actionList);
  }
  // next
  else if (parser_->isWord("next")) {
    parser_->skipChars(4);

    *action = CAwkNextAction::create();
  }
  // nextfile ??
  // return <pattern>
  // return
  else if (parser_->isWord("return")) {
    parser_->skipChars(6);

    CAwkExpressionPtr expression;

    (void) parseExpression(&expression);

    *action = CAwkReturnAction::create(expression);
  }
  // <simple_statement>
  else if (parseSimpleStatement(action)) {
  }
  // while <statement>
  else if (parser_->isWord("while")) {
    parser_->skipChars(5);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    if (isNewLine())
      parser_->skipChar();

    CAwkActionPtr action1;

    if (! parseStatement(&action1))
      return false;

    *action = CAwkWhileAction::create(expression, action1);
  }
  // input-output action
  else if (parseInputOutputAction(action)) {
  }
  // expression
  else {
    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    *action = CAwkExpressionAction::create(expression);
  }

  return true;
}

// <simple_statement>
bool
CAwk::
parseSimpleStatement(CAwkActionPtr *action)
{
  // printf <print_arg> '|' <terminal>
  // printf <print_arg> >> <terminal>
  // printf <print_arg> > <terminal>
  // printf <print_arg>
  if      (parser_->isWord("printf")) {
    parser_->skipChars(6);

    CAwkExpressionList expressionList;

    (void) parseRedirectExpressionList(expressionList);

    parser_->skipSpace();

    CAwkExpressionPtr fileExpr;

    CAwkOFilePtr file;

    if      (parser_->isChar('>')) {
      auto type = CAwkOFile::Type::WRITE_FILE;

      parser_->skipChar();

      if (parser_->isChar('>')) {
        parser_->skipChar();

        type = CAwkOFile::Type::APPEND_FILE;
      }

      if (! parseExpression(&fileExpr))
        return false;

      file = CAwkOFile::create(fileExpr, type);
    }
    else if (parser_->isChar('|')) {
      parser_->skipChar();

      if (! parseExpression(&fileExpr))
        return false;

      file = CAwkOFile::create(fileExpr, CAwkOFile::Type::PIPE_COMMAND);
    }

    *action = CAwkPrintFAction::create(expressionList, file);
  }
  // print <print_arg> '|' <terminal>
  // print <print_arg> >> <terminal>
  // print <print_arg> > <terminal>
  // print <print_arg>
  else if (parser_->isWord("print")) {
    parser_->skipChars(5);

    CAwkExpressionList expressionList;

    (void) parseRedirectExpressionList(expressionList);

    parser_->skipSpace();

    CAwkExpressionPtr fileExpr;

    CAwkOFilePtr file;

    if      (parser_->isChar('>')) {
      auto type = CAwkOFile::Type::WRITE_FILE;

      parser_->skipChar();

      if (parser_->isChar('>')) {
        parser_->skipChar();

        type = CAwkOFile::Type::APPEND_FILE;
      }

      if (! parseExpression(&fileExpr))
        return false;

      file = CAwkOFile::create(fileExpr, type);
    }
    else if (parser_->isChar('|')) {
      parser_->skipChar();

      if (! parseExpression(&fileExpr))
        return false;

      file = CAwkOFile::create(fileExpr, CAwkOFile::Type::PIPE_COMMAND);
    }

    *action = CAwkPrintAction::create(expressionList, file);
  }
  // delete <varname> '[' <pattern_list> ']'
  // delete <varname>
  else if (parser_->isWord("delete")) {
    parser_->skipChars(6);

    CAwkVariableRefPtr var;

    if (! parseVariable(&var))
      return false;

    CAwkExpressionPtr expression;

    parser_->skipSpace();

    if (parser_->isChar('[')) {
      if (! parseSubscript(&expression))
        return false;
    }

    *action = CAwkDeleteAction::create(var, expression);
  }
  // <pattern> ??
  else
    return false;

  return true;
}

bool
CAwk::
parseInputOutputAction(CAwkActionPtr *action)
{
  // close <term>
  if      (parser_->isWord("close")) {
    parser_->skipChars(5);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    *action = CAwkCloseAction::create(expression);
  }
  // getline <var> < <term>
  // getline < <term>
  // getline <var>
  // getline
  else if (parser_->isWord("getline")) {
    parser_->skipChars(7);

    CAwkVariableRefPtr var;

    (void) parseVariable(&var);

    parser_->skipSpace();

    CAwkExpressionPtr filePtr;

    if (parser_->isChar('<')) {
      parser_->skipChar();

      if (! parseExpressionValue(&filePtr))
        return false;
    }

    auto file = CAwkIFile::create(filePtr, CAwkIFile::Type::READ_FILE);

    *action = CAwkGetLineAction::create(var, file);
  }
  // <simple_statement>
  else if (parseSimpleStatement(action)) {
  }
  else if (parser_->isWord("system")) {
    parser_->skipChars(6);

    parser_->skipSpace();

    if (! parser_->isChar('(')) {
      error("Expected '('");
      return false;
    }

    parser_->skipChar();

    CAwkExpressionPtr expr;

    if (! parseExpression(&expr))
      return false;

    parser_->skipSpace();

    if (! parser_->isChar(')')) {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    *action = CAwkSystemAction::create(expr);
  }
  else
    return false;

  return true;
}

bool
CAwk::
parseRedirectExpressionList(CAwkExpressionList &expressionList)
{
  int redirect_pos = ioFindRedirect();

  std::string save_line;

  if (redirect_pos >= 0) {
    int save_pos = parser_->getPos();

    save_line = parser_->getString();

    std::string new_line = save_line.substr(0, redirect_pos);

    parser_->setString(new_line);
    parser_->setPos   (save_pos);
  }

  bool rc = parseExpressionList(expressionList);

  if (redirect_pos >= 0) {
    int save_pos = parser_->getPos();

    parser_->setString(save_line);
    parser_->setPos   (save_pos);
  }

  return rc;
}

bool
CAwk::
parseExpressionList(CAwkExpressionList &expressionList)
{
  parser_->skipSpace();

  char c = parser_->getCharAt();

  if (c == ')')
    return true;

  if (c == '(') {
    parser_->skipChar();

    parseExpressionList(expressionList);

    parser_->skipSpace();

    char c1 = parser_->getCharAt();

    if (c1 != ')') {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();
  }
  else {
    CAwkExpressionPtr expression;

    if (! parseExpression(&expression))
      return false;

    expressionList.push_back(expression);

    parser_->skipSpace();

    char c1 = parser_->getCharAt();

    while (c1 == ',') {
      parser_->skipChar();

      if (isNewLine())
        parser_->skipChar();

      if (! parseExpression(&expression))
        return false;

      expressionList.push_back(expression);

      parser_->skipSpace();

      c1 = parser_->getCharAt();
    }
  }

  return true;
}

bool
CAwk::
parseExpression(CAwkExpressionPtr *expression)
{
  auto expression1 = CAwkExpression::create();

  while (true) {
    parser_->skipSpace();

    if (parser_->eof())
      break;

    CAwkExpressionTermPtr term;

    if (! parseExpressionTerm(&term, expression1->isValue()))
      return false;

    if (! term)
      break;

    expression1->pushTerm(term);
  }

  if (expression1->numTerms() == 0)
    return false;

  *expression = expression1;

  if (getDebug())
    std::cerr << *expression << std::endl;

  return true;
}

bool
CAwk::
parseExpressionValue(CAwkExpressionPtr *expression)
{
  auto expression1 = CAwkExpression::create();

  while (true) {
    parser_->skipSpace();

    if (parser_->eof())
      break;

    CAwkExpressionTermPtr term;

    if (! parseExpressionTerm(&term, expression1->isValue()))
      return false;

    if (! term)
      break;

    expression1->pushTerm(term);

    if (expression1->isValue())
      break;
  }

  if (expression1->numTerms() == 0)
    return false;

  *expression = expression1;

  if (getDebug())
    std::cerr << *expression << std::endl;

  return true;
}

bool
CAwk::
parseExpressionTerm(CAwkExpressionTermPtr *term, bool isValue)
{
  char c = parser_->getCharAt();

  // <string>
  if      (c == '"') {
    CAwkValuePtr value;

    if (! parseString(&value))
      return false;

    *term = value.refCast<CAwkExpressionTerm>();
  }
  // <number>
  else if (isdigit(c) || c == '.') {
    CAwkValuePtr real;

    if (! parseNumber(&real))
      return false;

    *term = real.refCast<CAwkExpressionTerm>();
  }
  // ( <pattern> )
  else if (c == '(') {
    parser_->skipChar();

    CAwkExpressionPtr expression2;

    if (! parseExpression(&expression2))
      return false;

    parser_->skipSpace();

    char c1 = parser_->getCharAt();

    if (c1 != ')') {
      error("Expected ')'");
      return false;
    }

    parser_->skipChar();

    *term = expression2.refCast<CAwkExpressionTerm>();
  }
  else if (c == '/' && ! isValue) {
    std::string regexp;

    if (! parseRegularExpression(regexp))
      return false;

    // TODO: regexp value ?
    auto value = CAwkValue::create(regexp);

    *term = value.refCast<CAwkExpressionTerm>();
  }
  // getline var [< file]
  else if (parser_->isWord("getline")) {
    parser_->skipChars(7);

    CAwkVariableRefPtr var;

    (void) parseVariable(&var);

    parser_->skipSpace();

    CAwkExpressionPtr filePtr;

    if (parser_->isChar('<')) {
      parser_->skipChar();

      if (! parseExpressionValue(&filePtr))
        return false;
    }

    auto file = CAwkIFile::create(filePtr, CAwkIFile::Type::READ_FILE);

    auto expr = CAwkGetLineExpr::create(var, file, /*hasValue*/true);

    *term = expr;
  }
  // <ppattern> ~ <regexp>
  // <ppattern> ~ <ppattern>
  else if (parser_->isString("!~")) {
    parser_->skipChars(2);

    auto op = CAwkNotRegExpOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <ppattern> !~ <regexp>
  // <ppattern> !~ <ppattern>
  else if (parser_->isString("~")) {
    parser_->skipChar();

    auto op = CAwkRegExpOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }

  // <ppattern> ? <ppattern> : <ppattern>
  else if (isValue && strchr("?:", c) != 0) {
    parser_->skipChar();

    CAwkOperatorPtr op;

    if (c == '?')
      op = CAwkQuestionOperator::create();
    else
      op = CAwkColonOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <ppattern> || <ppattern>
  else if (parser_->isString("||")) {
    parser_->skipChars(2);

    auto op = CAwkLogicalOrOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <ppattern> && <ppattern>
  else if (parser_->isString("&&")) {
    parser_->skipChars(2);

    auto op = CAwkLogicalAndOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern == pattern
  else if (parser_->isString("==")) {
    parser_->skipChars(2);

    auto op = CAwkEqualsOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern >= pattern
  else if (parser_->isString(">=")) {
    parser_->skipChars(2);

    auto op = CAwkGreaterEqualsOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern >  pattern
  else if (parser_->isString(">")) {
    parser_->skipChar();

    auto op = CAwkGreaterOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern <= pattern
  else if (parser_->isString("<=")) {
    parser_->skipChars(2);

    auto op = CAwkLessEqualsOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern <  pattern
  else if (parser_->isString("<")) {
    parser_->skipChar();

    auto op = CAwkLessOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <pattern != pattern
  else if (parser_->isString("!=")) {
    parser_->skipChars(2);

    auto op = CAwkNotEqualsOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <ppattern> in <varname>
  // ( <pattern_list> ) in <varname>
  else if (parser_->isWord("in")) {
    parser_->skipChars(2);

    auto op = CAwkInOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }

  // <ppattern> <term>
  // <regexp>
  // ! <regexp>

  // <term>

  // ++ <var>
  // <var> ++
  else if (parser_->isString("++")) {
    parser_->skipChars(2);

    CAwkOperatorPtr op;

    if (isValue)
      op = CAwkPostIncrementOperator::create();
    else
      op = CAwkPreIncrementOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <var> --
  // -- <var>
  else if (parser_->isString("--")) {
    parser_->skipChars(2);

    CAwkOperatorPtr op;

    if (isValue)
      op = CAwkPostDecrementOperator::create();
    else
      op = CAwkPreDecrementOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // <term> = <term>
  // <term> += <term>
  // <term> -= <term>
  // <term> *= <term>
  // <term> /= <term>
  // <term> %= <term>
  // <term> ^= <term>
  // <term> + <term>
  // <term> - <term>
  // <term> * <term>
  // <term> / <term>
  // <term> % <term>
  // <term> ^ <term>
  else if (isValue && strchr("=+-*/%^", c) != 0) {
    CAwkOperatorPtr op;

    if (! parseOperator(&op, isValue))
      return false;

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // + <term>
  // - <term>
  // ! <term>
  else if (! isValue && strchr("+-!", c) != 0) {
    CAwkOperatorPtr op;

    if (! parseOperator(&op, isValue))
      return false;

    *term = op.refCast<CAwkExpressionTerm>();
  }
  // $ <term>
  else if (c == '$') {
    parser_->skipChar();

    auto op = CAwkFieldOperator::create();

    *term = op.refCast<CAwkExpressionTerm>();
  }

  // <builtin> ( )
  // <builtin> ( <pattern_list> )
  // <builtin>
  else if (isalpha(c) || c == '_') {
    std::string name;

    if (! parseIdentifier(name))
      return false;

    parser_->skipSpace();

    if      (parser_->isChar('(')) {
      parser_->skipChar();

      CAwkExpressionList expressionList;

      if (! parseExpressionList(expressionList))
        return false;

      parser_->skipSpace();

      if (! parser_->isChar(')')) {
        error("Expected ')'");
        return false;
      }

      parser_->skipChar();

      auto function = CAwkExprFunction::create(this, name, expressionList);

      *term = function.refCast<CAwkExpressionTerm>();
    }
    else if (parser_->isChar('[')) {
      parser_->skipChar();

      CAwkExpressionList expressionList;

      if (! parseExpressionList(expressionList))
        return false;

      parser_->skipSpace();

      if (! parser_->isChar(']')) {
        error("Expected ']'");
        return false;
      }

      parser_->skipChar();

      auto var = CAwkArrayVariableRef::create(name, expressionList);

      *term = var.refCast<CAwkExpressionTerm>();
    }
    else {
      auto var = CAwkVariableRef::create(name);

      *term = var.refCast<CAwkExpressionTerm>();
    }
  }
  else {
    *term = CAwkExpressionTermPtr();
    return true;
  }

  // <term> | getline <var>
  if ((*term)->hasValue()) {
    parser_->skipSpace();

    if (parser_->isChar('|')) {
      int save_pos = parser_->getPos();

      parser_->skipChar();

      parser_->skipSpace();

      if (parser_->isWord("getline")) {
        parser_->skipChars(7);

        CAwkVariableRefPtr var;

        (void) parseVariable(&var);

        parser_->skipSpace();

        auto filePtr = CAwkExpression::create();

        filePtr->pushTerm(*term);

        auto file = CAwkIFile::create(filePtr, CAwkIFile::Type::PIPE_COMMAND);

        *term = CAwkGetLineExpr::create(var, file, /*hasValue*/false);
      }
      else
        parser_->setPos(save_pos);
    }
  }

  return true;
}

bool
CAwk::
parseRegularExpression(std::string &regexp)
{
  if (! parser_->isChar('/'))
    return false;

  parser_->skipChar();

  while (! parser_->eof() && ! parser_->isChar('/')) {
    regexp += parser_->getCharAt();

    parser_->skipChar();
  }

  if (! parser_->isChar('/')) {
    error("Expected '/'");
    return false;
  }

  parser_->skipChar();

  return true;
}

bool
CAwk::
parseSubscript(CAwkExpressionPtr *expression)
{
  if (! parser_->isChar('['))
    return false;

  parser_->skipChar();

  if (! parseExpression(expression))
    return false;

  parser_->skipSpace();

  if (! parser_->isChar(']')) {
    error("Expected ']'");
    return false;
  }

  parser_->skipChar();

  return true;
}

// <varname> [ <pattern_list> ]

bool
CAwk::
parseVariable(CAwkVariableRefPtr *var)
{
  std::string name;

  if (! parseIdentifier(name))
    return false;

  *var = CAwkVariableRef::create(name);

  if (getDebug())
    std::cerr << *var << std::endl;

  return true;
}

// <varname>
bool
CAwk::
parseIdentifier(std::string &name)
{
  parser_->skipSpace();

  char c = parser_->getCharAt();

  if (! isalpha(c) && c != '_')
    return false;

  name += c;

  parser_->skipChar();

  c = parser_->getCharAt();

  while (! parser_->eof() &&
         (isalnum(c) || c == '_')) {
    name += c;

    parser_->skipChar();

    c = parser_->getCharAt();
  }

  return true;
}

bool
CAwk::
parseString(CAwkValuePtr *value)
{
  std::string str;

  if (! parseString(str))
    return false;

  *value = CAwkValue::create(str);

  return true;
}

bool
CAwk::
parseString(std::string &str)
{
  parser_->skipSpace();

  char c = parser_->getCharAt();

  if (c == '"') {
    std::string str1;

    if (! parser_->readString(str1)) {
      error("Expected '\"'");
      return false;
    }

    // remove quotes
    str = str1.substr(1, str1.size() - 2);
  }
  else
    return false;

  str = CStrUtil::replaceEscapeCodes(str);

  return true;
}

bool
CAwk::
parseNumber(CAwkValuePtr *value)
{
  char c = parser_->getCharAt();

  if (isdigit(c)) {
    int integer;

    int save_pos = parser_->getPos();

    if (! parser_->readInteger(&integer))
      return false;

    char c1 = parser_->getCharAt();

    if (c1 == '.' || c1 == 'E') {
      parser_->setPos(save_pos);

      double real;

      if (!  parser_->readReal(&real))
        return false;

      *value = CAwkValue::create(real);
    }
    else
      *value = CAwkValue::create(integer);
  }
  else {
    double real;

    if (! parser_->readReal(&real))
      return false;

    *value = CAwkValue::create(real);
  }

  return true;
}

bool
CAwk::
parseOperator(CAwkOperatorPtr *op, bool value)
{
  parser_->skipSpace();

  char c = parser_->getCharAt();

  if      (c == '=') {
    parser_->skipChar();

    *op = CAwkAssignOperator::create();
  }
  else if (c == '+') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkPlusEqualsOperator::create();
    }
    else {
      if (value)
        *op = CAwkPlusOperator::create();
      else
        *op = CAwkUnaryPlusOperator::create();
    }
  }
  else if (c == '-') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkMinusEqualsOperator::create();
    }
    else {
      if (value)
        *op = CAwkMinusOperator::create();
      else
        *op = CAwkUnaryMinusOperator::create();
    }
  }
  else if (c == '*') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkTimesEqualsOperator::create();
    }
    else
      *op = CAwkTimesOperator::create();
  }
  else if (c == '/') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkDivideEqualsOperator::create();
    }
    else
      *op = CAwkDivideOperator::create();
  }
  else if (c == '%') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkModulusEqualsOperator::create();
    }
    else
      *op = CAwkModulusOperator::create();
  }
  else if (c == '^') {
    parser_->skipChar();

    char c1 = parser_->getCharAt();

    if      (c1 == '=') {
      parser_->skipChar();

      *op = CAwkPowerEqualsOperator::create();
    }
    else
      *op = CAwkPowerOperator::create();
  }
  else if (c == '!') {
    parser_->skipChar();

    *op = CAwkLogicalNotOperator::create();
  }
  else if (c == '$') {
    parser_->skipChar();

    *op = CAwkFieldOperator::create();
  }
  else
    return false;

  return true;
}

int
CAwk::
ioFindRedirect()
{
  int in_brackets = 0;

  int save_pos = parser_->getPos();

  while (! parser_->eof()) {
    char c = parser_->getCharAt();

    if      (c == '(') {
      ++in_brackets;

      parser_->skipChar();
    }
    else if (c == ')') {
      --in_brackets;

      parser_->skipChar();
    }
    else if (c == '"') {
      parser_->skipString();

      parser_->skipChar();
    }
    else if (c == '>') {
      if (in_brackets == 0) {
        int pos = parser_->getPos();

        parser_->setPos(save_pos);

        return pos;
      }

      parser_->skipChar();
    }
    else
      parser_->skipChar();
  }

  parser_->setPos(save_pos);

  return -1;
}

bool
CAwk::
isNewLine()
{
  if (parser_->eof()) {
    std::string line;

    if (! readLine(line))
      return false;

    int save_pos = parser_->getPos();

    std::string current_line = parser_->getString();

    current_line += "#" + line;

    parser_->setString(current_line);
    parser_->setPos   (save_pos);

    return true;
  }

  return parser_->isChar('#');
}

bool
CAwk::
readLine(std::string &line)
{
  if (! input_file_->readLine(line))
    return false;

  line = removeComments(line);

  line = CStrUtil::stripSpaces(line);

  ++line_num_;

  uint len = line.size();

  if (len > 0 && line[len - 1] == '\\') {
    line = line.substr(0, len - 1);

    std::string line1;

    (void) readLine(line1);

    line += line1;
  }

  return true;
}

std::string
CAwk::
removeComments(const std::string &line)
{
  std::string line1;

  uint len = line.size();

  uint i = 0;

  while (i < len) {
    // skip string
    if      (line[i] == '\"') {
      uint j = i;

      if (! CStrUtil::skipDoubleQuotedString(line, &i))
        return "";

      line1 += line.substr(j, i - j);
    }
    // skip regexp
    else if (line[i] == '/') {
      uint j = i;

      ++i;

      while (i < len && line[i] != '/') {
        if (line[i] == '\\')
          ++i;

        ++i;
      }

      if (line[i] == '/')
        ++i;

      line1 += line.substr(j, i - j);
    }
    else if (line[i] == '#')
      break;
    else
      line1 += line[i++];
  }

  return line1;
}

CAwkValuePtr
CAwk::
getValue(CAwkExpressionTermPtr term)
{
  if      (term.canCast<CAwkValue>())
    return term.refCast<CAwkValue>();
  else if (term->hasValue())
    return term->getValue();
  else
    return CAwkValuePtr();
}

CAwkVariableRefPtr
CAwk::
getVariableRef(CAwkExpressionTermPtr term)
{
  auto term1 = term->execute();

  if (term1.canCast<CAwkVariableRef>())
    return term1.refCast<CAwkVariableRef>();
  else
    return CAwkVariableRefPtr();
}

CAwkVariablePtr
CAwk::
getVariable(const std::string &name, bool create, bool global) const
{
  CAwkVariablePtr variable;

  // check if variable already exists in current block or any parent block
  if (currentBlock_) {
    variable = currentBlock_->getVariable(name);

    if (variable)
      return variable;

    auto p1 = blockStack_.rbegin();
    auto p2 = blockStack_.rend  ();

    for ( ; p1 != p2; ++p1) {
      variable = (*p1)->getVariable(name);

      if (variable)
        return variable;
    }
  }

  //---

  // get from global scope
  variable = variableMgr_.getVariable(name);

  if (variable)
    return variable;

  //---

  if (create) {
    auto *th = const_cast<CAwk *>(this);

    return th->addVariable(name, global);
  }

  return CAwkVariablePtr();
}

CAwkVariablePtr
CAwk::
addVariable(const std::string &name, bool global)
{
  if (! global && currentBlock_)
    return currentBlock_->addVariable(name);

  //---

  auto variable = CAwkVariable::create(name, "");

  variableMgr_.addVariable(variable);

  return variable;
}

CFile *
CAwk::
getFile(FILE *file)
{
  return fileMgr_.getFile(file);
}

CFile *
CAwk::
getFile(const std::string &fileName, CFileBase::Mode mode)
{
  return fileMgr_.getFile(fileName, mode);
}

bool
CAwk::
closeFile(const std::string &fileName)
{
  return fileMgr_.closeFile(fileName);
}

CAwkPipe *
CAwk::
getPipe(const std::string &cmdName, CAwkPipe::Type type)
{
  return pipeMgr_.getPipe(cmdName, type);
}

bool
CAwk::
closePipe(const std::string &cmdName)
{
  return pipeMgr_.closePipe(cmdName);
}

void
CAwk::
startBlock(CAwkActionBlockPtr block)
{
  if (currentBlock_)
    blockStack_.push_back(currentBlock_);

  currentBlock_ = block;
}

void
CAwk::
endBlock()
{
  if (! blockStack_.empty()) {
    currentBlock_ = blockStack_.back();

    blockStack_.pop_back();
  }
  else
    currentBlock_ = CAwkActionBlockPtr();
}

void
CAwk::
error(const std::string &str) const
{
  std::string lhs = parser_->getString().substr(0, parser_->getPos());
  std::string rhs = parser_->getString().substr(parser_->getPos());

  std::cerr << file_name_ << "@" << line_num_ << "," << parser_->getPos() << std::endl;
  std::cerr << lhs << '^' << rhs << std::endl;
  std::cerr << str << std::endl;
}
##concat##CAwkExecuteStack.cpp
#include <CAwk.h>
#include <CFuncs.h>

CAwkExecuteStack::
CAwkExecuteStack()
{
}

CAwkExecuteStack::
~CAwkExecuteStack()
{
}

void
CAwkExecuteStack::
begin()
{
  executeSubStackStack_.push_back(executeSubStack_);

  executeSubStack_ = new CAwkExecuteSubStack;
}

void
CAwkExecuteStack::
end()
{
  delete executeSubStack_;

  executeSubStack_ = executeSubStackStack_.back();

  executeSubStackStack_.pop_back();
}

double
CAwkExecuteStack::
popReal()
{
  auto value = popValue();

  return value->getReal();
}

CAwkVariableRefPtr
CAwkExecuteStack::
popVariableRef()
{
  return executeSubStack_->popVariableRef();
}

CAwkValuePtr
CAwkExecuteStack::
popValue()
{
  return executeSubStack_->popValue();
}

CAwkExpressionTermPtr
CAwkExecuteStack::
popTerm()
{
  return executeSubStack_->popTerm();
}

void
CAwkExecuteStack::
addTerm(CAwkOperatorPtr op)
{
  executeSubStack_->addTerm(op);
}

void
CAwkExecuteStack::
addTerm(CAwkExpressionTermPtr term)
{
  executeSubStack_->addTerm(term);
}

bool
CAwkExecuteStack::
checkUnstack(CAwkOperatorPtr op)
{
  return executeSubStack_->checkUnstack(op);
}

void
CAwkExecuteStack::
unstackExpression()
{
  executeSubStack_->unstackExpression();
}

bool
CAwkExecuteStack::
hasLastOp() const
{
  return executeSubStack_->hasLastOp();
}

void
CAwkExecuteStack::
print(std::ostream &os) const
{
  executeSubStack_->print(os);
}

//------------------

CAwkExecuteSubStack::
CAwkExecuteSubStack()
{
}

void
CAwkExecuteSubStack::
addTerm(CAwkOperatorPtr op)
{
  if (lastOp_)
    opStack_.push_back(lastOp_);

  termList_.push_back(op.refCast<CAwkExpressionTerm>());

  lastOp_ = op;
  value_  = false;
}

void
CAwkExecuteSubStack::
addTerm(CAwkExpressionTermPtr term)
{
  if (term->hasValue()) {
    if (value_) {
      auto op = CAwkConcatOperator::create();

      addTerm(op);
    }

    termList_.push_back(term.refCast<CAwkExpressionTerm>());

    value_ = true;
  }
  else
    assert(false);
}

bool
CAwkExecuteSubStack::
checkUnstack(CAwkOperatorPtr op)
{
  if (lastOp_) {
    if (lastOp_->getPrecedence() > op->getPrecedence() ||
        (lastOp_->getPrecedence() == op->getPrecedence() &&
         op->getDirection() == CAwkOperator::Direction::L_TO_R))
      return true;
  }

  return false;
}

void
CAwkExecuteSubStack::
unstackExpression()
{
  CAwkExpressionTermPtr rterm;

  CAwkOperatorPtr op;

  auto term1 = termList_.back();

  termList_.pop_back();

  auto term2 = termList_.back();

  termList_.pop_back();

  if      (term1->hasValue()) {
    rterm = term1;

    op = term2.refCast<CAwkOperator>();
  }
  else if (term2.canCast<CAwkOperator>()) {
    op = term2.refCast<CAwkOperator>();

    rterm = term1;
  }
  else if (term1.canCast<CAwkOperator>()) {
    op = term1.refCast<CAwkOperator>();

    rterm = term2;
  }
  else
    assert(false);

  CAwkExpressionTermPtr result;

  if      (op->isUnary()) {
    termList_.push_back(rterm);

    result = op->execute();

    if (! opStack_.empty()) {
      lastOp_ = opStack_.back();

      opStack_.pop_back();
    }
    else
      lastOp_ = CAwkOperatorPtr();

    if (! termList_.empty()) {
      auto last_term = termList_.back();

      value_ = last_term->hasValue();
    }
    else
      value_ = false;
  }
  else if (op->isBinary()) {
    auto term3 = termList_.back();

    termList_.pop_back();

    auto lterm = term3;

    termList_.push_back(lterm);
    termList_.push_back(rterm);

    result = op->execute();

    if (! opStack_.empty()) {
      lastOp_ = opStack_.back();

      opStack_.pop_back();
    }
    else
      lastOp_ = CAwkOperatorPtr();

    if (! termList_.empty()) {
      auto last_term = termList_.back();

      value_ = last_term->hasValue();
    }
    else
      value_ = false;
  }
  else if (op->isTernary()) {
    // can only be ? or :
    auto term3 = termList_.back();

    termList_.pop_back();

    auto lterm = term3;

    auto lvalue = CAwkInst->getValue(lterm);

    if (op.cast<CAwkQuestionOperator>() != nullptr) {
      bool flag = lvalue->getBool();

      if (flag)
        result = rterm;
      else
        result = CAwkNullValue::create();
    }
    else {
      if (lvalue.cast<CAwkNullValue>())
        result = rterm;
      else
        result = lterm;
    }

    if (! opStack_.empty()) {
      lastOp_ = opStack_.back();

      opStack_.pop_back();
    }
    else
      lastOp_ = CAwkOperatorPtr();

    if (! termList_.empty()) {
      auto last_term = termList_.back();

      value_ = last_term->hasValue();
    }
    else
      value_ = false;
  }
  else
    assert(false);

  addTerm(result);
}

CAwkVariableRefPtr
CAwkExecuteSubStack::
popVariableRef()
{
  auto term = termList_.back();

  termList_.pop_back();

  if (term.canCast<CAwkVariableRef>())
    return term.refCast<CAwkVariableRef>();
  else
    return CAwkVariableRefPtr();
}

CAwkValuePtr
CAwkExecuteSubStack::
popValue()
{
  auto term = popTerm();

  return CAwkInst->getValue(term);
}

CAwkExpressionTermPtr
CAwkExecuteSubStack::
popTerm()
{
  auto term = termList_.back();

  termList_.pop_back();

  return term;
}

void
CAwkExecuteSubStack::
print(std::ostream &os) const
{
  os << "value=\"" << (value_ ? "true" : "false") << "\"";

  if (! termList_.empty()) {
    os << ", terms=\"";

    for_each(termList_.begin(), termList_.end(), CPrintSeparated<CAwkExpressionTermPtr>(os));

    os << "\"";
  }

  if (lastOp_ || ! opStack_.empty()) {
    os << ", ops=\"";

    for_each(opStack_.begin(), opStack_.end(), CPrintSeparated<CAwkOperatorPtr>(os));

    if (lastOp_) {
      if (! opStack_.empty())
        os << " ";

      lastOp_->print(os);
    }

    os << "\"";
  }
}
##concat##CAwkExpression.cpp
#include <CAwk.h>
#include <CFuncs.h>
#include <CReadLine.h>

CAwkExpression::
CAwkExpression()
{
}

CAwkValuePtr
CAwkExpression::
getValue() const
{
  auto *th = const_cast<CAwkExpression *>(this);

  auto term = th->execute();

  return CAwkInst->getValue(term);
}

void
CAwkExpression::
pushTerm(CAwkExpressionTermPtr term)
{
  if      (term.canCast<CAwkOperator>()) {
    auto op = term.refCast<CAwkOperator>();

    if (value_ && op->isUnary()) {
      if ((op.cast<CAwkPostIncrementOperator>() == nullptr) &&
          (op.cast<CAwkPostDecrementOperator>() == nullptr)) {
        auto op1 = CAwkConcatOperator::create();

        pushTerm(op1.refCast<CAwkExpressionTerm>());
      }
    }

    termList_.push_back(term);

    if (lastOp_)
      opStack_.push_back(lastOp_);

    lastOp_ = op;
    value_  = false;
  }
  else if (term->hasValue()) {
    if (value_) {
      auto op = CAwkConcatOperator::create();

      pushTerm(op.refCast<CAwkExpressionTerm>());
    }

    termList_.push_back(term);

    value_ = true;
  }
  else if (term.canCast<CAwkGetLineExpr>()) {
    auto expr = term.refCast<CAwkGetLineExpr>();

    auto term1 = expr->execute();

    termList_.push_back(term1);

    value_ = true;
  }
  else
    assert(false);
}

CAwkExpressionTermPtr
CAwkExpression::
execute()
{
  auto *awk = CAwkInst;

  auto &executeStack = awk->getExecuteStack();

  executeStack.begin();

  if (awk->getDebug())
    std::cout << executeStack << std::endl;

  auto p1 = termList_.begin();
  auto p2 = termList_.end  ();

  for ( ; p1 != p2; ++p1) {
    auto term = *p1;

    if      (term.canCast<CAwkOperator>()) {
      auto op = term.refCast<CAwkOperator>();

      while (executeStack.checkUnstack(op)) {
        executeStack.unstackExpression();

        if (awk->getDebug())
          std::cout << executeStack << std::endl;
      }

      executeStack.addTerm(op);
    }
    else if (term.canCast<CAwkExprFunction>()) {
      auto func = term.refCast<CAwkExprFunction>();

      auto term1 = func->execute();

      if (term1)
        executeStack.addTerm(term1);
      else {
        auto result = CAwkValue::create("");

        executeStack.addTerm(result.refCast<CAwkExpressionTerm>());
      }
    }
    else if (term->hasValue()) {
      executeStack.addTerm(term);
    }
    else
      assert(false);

    if (awk->getDebug())
      std::cout << executeStack << std::endl;
  }

  while (executeStack.hasLastOp()) {
    executeStack.unstackExpression();

    if (awk->getDebug())
      std::cout << executeStack << std::endl;
   }

  auto term = executeStack.popTerm();

  executeStack.end();

  return term;
}

void
CAwkExpression::
print(std::ostream &os) const
{
  os << "(";

  for_each(termList_.begin(), termList_.end(),
           CPrintSeparated<CAwkExpressionTermPtr>(os));

  os << ")";
}

//-------------

CAwkValuePtr
CAwkGetLineExpr::
getValue() const
{
  std::string line;

  if (file_) {
    std::string str;

    file_->read(line);
  }
  else {
    CReadLine readline;

    line = readline.readLine();
  }

  auto value = CAwkValue::create(line);

  if (var_) {
    var_->setValue(value);
  }

  return value;
}

CAwkExpressionTermPtr
CAwkGetLineExpr::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}

void
CAwkGetLineExpr::
print(std::ostream &os) const
{
  os << "getline";

  if (var_)
    os << " " << *var_;

  if (file_)
    os << " " << *file_;
}
##concat##CAwkFunction.cpp
#include <CAwk.h>
#include <CFuncs.h>
#include <CPrintF.h>
#include <CMathRand.h>
#include <CStrUtil.h>
#include <CRegExp.h>
#include <cmath>

void
CAwkFunctionMgr::
clear()
{
  functionMap_.clear();
}

void
CAwkFunctionMgr::
addFunction(CAwkFunctionPtr function)
{
  functionMap_[function->getName()] = function;
}

CAwkFunctionPtr
CAwkFunctionMgr::
getFunction(const std::string &name) const
{
  auto p = functionMap_.find(name);

  if (p != functionMap_.end())
    return p->second;

  return CAwkFunctionPtr();
}

void
CAwkFunctionMgr::
print(std::ostream &os) const
{
  CPrintSeparated<CAwkFunction> ps(os);

  for (const auto &f : functionMap_)
    ps(f.second.get());
}

//-------------

CAwkValuePtr
CAwkParseFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() > args_.size()) {
    awk_->error("Too many function args");
    return CAwkValue::create("");
  }

  auto block = CAwkActionBlock::create(actionList_);

  awk_->startBlock(block);

  // assign values to args
  auto pa1 = args_.begin();
  auto pa2 = args_.end();

  auto pv1 = values.begin();
  auto pv2 = values.end  ();

  for ( ; pa1 != pa2 && pv1 != pv2; ++pa1, ++pv1)
    awk_->addVariable(*pa1)->setValue((*pv1)->getValue());

  // these extra arguments are for local variables
  for ( ; pa1 != pa2; ++pa1)
    awk_->addVariable(*pa1)->setValue(CAwkValue::create(""));

  // TODO: new variables are created in global scope !!

  // execute block
  block->exec();

  auto retValue = awk_->getReturnValue();

  // TODO: old variable list
  awk_->endBlock();

  return retValue;
}

void
CAwkParseFunction::
print(std::ostream &os) const
{
  os << "function " << name_ << "(";

  for_each(args_.begin(), args_.end(), CPrintSeparated<std::string>(os));

  os << ") ";

  actionList_->print(os);
}

//-------------

CAwkValuePtr
CAwkExprFunction::
getValue() const
{
  auto function = awk_->getFunction(name_);

  if (! function) {
    awk_->error("No function '" + name_ + "'");
    return CAwkValue::create("");
  }

  CAwkExpressionTermList values;

  auto p1 = expressionList_.begin();
  auto p2 = expressionList_.end  ();

  for ( ; p1 != p2; ++p1)
    values.push_back((*p1).refCast<CAwkExpressionTerm>());

  return function->exec(values);
}

CAwkExpressionTermPtr
CAwkExprFunction::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}

void
CAwkExprFunction::
print(std::ostream &os) const
{
  os << name_ << "(";

  for_each(expressionList_.begin(), expressionList_.end(),
           CPrintSeparated<CAwkExpressionPtr>(os, ","));

  os << ")";
}

//-------------

CAwkValuePtr
CAwkGsubFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2 && values.size() != 3) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string regstr = values[0]->getValue()->getString();

  CRegExp regexp(regstr);

  regexp.setExtended(true);

  std::string rstr = values[1]->getValue()->getString();

  int count;

  std::string str, ostr;

  if (values.size() == 3) {
    auto var = awk_->getVariableRef(values[2]);

    if (! var) {
      awk_->error("Invalid LHS");
      return CAwkValue::create(0);
    }

    str = var->getValue()->getString();

    count = CRegExpUtil::gregsub(str, regexp, rstr, ostr);

    var->setValue(CAwkValue::create(ostr));
  }
  else {
    str = awk_->getLineField(0);

    count = CRegExpUtil::gregsub(str, regexp, rstr, ostr);

    awk_->setLineField(0, ostr);
  }

  return CAwkValue::create(count);
}

void
CAwkGsubFunction::
print(std::ostream &os) const
{
  os << "gsub()";
}

CAwkValuePtr
CAwkIndexFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string str1 = values[0]->getValue()->getString();
  std::string str2 = values[1]->getValue()->getString();

  int pos = str1.find(str2);

  return CAwkValue::create(pos + 1);
}

void
CAwkIndexFunction::
print(std::ostream &os) const
{
  os << "index()";
}

CAwkValuePtr
CAwkLengthFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string str = values[0]->getValue()->getString();

  int result = str.size();

  return CAwkValue::create(result);
}

void
CAwkLengthFunction::
print(std::ostream &os) const
{
  os << "length()";
}

CAwkValuePtr
CAwkMatchFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string str1 = values[0]->getValue()->getString();
  std::string str2 = values[1]->getValue()->getString();

  CRegExp regexp(str2);

  regexp.setExtended(true);

  bool match = regexp.find(str1);

  if (match) {
    int start, end;

    regexp.getMatchRange(&start, &end);

    awk_->getVariable("RSTART" )->setValue(CAwkValue::create(start + 1));
    awk_->getVariable("RLENGTH")->setValue(CAwkValue::create(end - start + 1));

    return CAwkValue::create(start + 1);
  }
  else
    return CAwkValue::create("");
}

void
CAwkMatchFunction::
print(std::ostream &os) const
{
  os << "match()";
}

CAwkValuePtr
CAwkSplitFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2 && values.size() != 3) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  // string to split
  std::string str = values[0]->getValue()->getString();

  // array variable to split into
  auto var = awk_->getVariableRef(values[1]);

  if (! var) {
    awk_->error("Invalid LHS");
    return CAwkValue::create(0);
  }

  // field separators
  std::string fs;

  if (values.size() == 3)
    fs = values[2]->getValue()->getString();
  else
    fs = awk_->getVariable("FS")->getValue()->getString();

  if (fs == " ")
    fs = " \t";

  //---

  // split into fields
  StringVectorT fields;

  CStrUtil::addFields(str, fields, fs, /*skipEmpty*/true);

  //---

  // ensure variable exists (create in global scope)
  (void) var->instantiate(/*global*/true);

  //---

  // strore fields in array variable
  uint numFields = fields.size();

  for (uint i = 0; i < numFields; ++i)
    var->setIndValue(CStrUtil::toString(i + 1), CAwkValue::create(fields[i]));

  //---

  // return number of fields
  return CAwkValue::create(int(numFields));
}

void
CAwkSplitFunction::
print(std::ostream &os) const
{
  os << "split()";
}

CAwkValuePtr
CAwkSprintfFunction::
exec(const CAwkExpressionTermList &values)
{
  class PrintF : public CPrintF {
   private:
    const CAwkExpressionTermList &values_;
    mutable uint                        pos_;

   public:
    PrintF(const std::string &format, const CAwkExpressionTermList &values) :
     CPrintF(format), values_(values), pos_(1) {
    }

    int         getInt     () const { return getValue()->getInteger(); }
    long        getLong    () const { return getValue()->getInteger(); }
    long        getLongLong() const { return getValue()->getInteger(); }
    double      getDouble  () const { return getValue()->getReal   (); }
    std::string getString  () const { return getValue()->getString (); }

    CAwkValuePtr getValue() const {
      CAwkValuePtr value;

      if (pos_ < values_.size()) {
        value = values_[pos_]->getValue();

        ++pos_;
      }

      if (! value)
        value = CAwkValue::create("");

      return value;
    }
  };

  if (values.size() < 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string format = values[0]->getValue()->getString();

  PrintF printf(format, values);

  std::string str = printf.format();

  return CAwkValue::create(str);
}

void
CAwkSprintfFunction::
print(std::ostream &os) const
{
  os << "sprintf()";
}

CAwkValuePtr
CAwkSubFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2 && values.size() != 3) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string regstr = values[0]->getValue()->getString();

  CRegExp regexp(regstr);

  regexp.setExtended(true);

  std::string rstr = values[1]->getValue()->getString();

  int count = 0;

  std::string str, ostr;

  if (values.size() == 3) {
    auto var = awk_->getVariableRef(values[2]);

    if (! var) {
      awk_->error("Invalid LHS");
      return CAwkValue::create(0);
    }

    str = var->getValue()->getString();

    if (CRegExpUtil::regsub(str, regexp, rstr, ostr))
      ++count;

    var->setValue(CAwkValue::create(ostr));
  }
  else {
    str = awk_->getLineField(0);

    if (CRegExpUtil::regsub(str, regexp, rstr, ostr))
      ++count;

    awk_->setLineField(0, ostr);
  }

  return CAwkValue::create(count);
}

void
CAwkSubFunction::
print(std::ostream &os) const
{
  os << "sub()";
}

CAwkValuePtr
CAwkSubstrFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2 && values.size() != 3) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  std::string str = values[0]->getValue()->getString ();
  int         pos = values[1]->getValue()->getInteger();

  if (values.size() == 3) {
    int len = values[2]->getValue()->getInteger();

    auto res =  str.substr(pos - 1, len);

    if (awk_->getDebug())
      std::cout << "substr(" << str << ", " << pos - 1 << ", " << len << ") = " << res << "\n";

    return CAwkValue::create(res);
  }
  else {
    auto res =  str.substr(pos - 1);

    if (awk_->getDebug())
      std::cout << "substr(" << str << ", " << pos - 1 << ") = " << res << "\n";

    return CAwkValue::create(res);
  }

  return CAwkValuePtr();
}

void
CAwkSubstrFunction::
print(std::ostream &os) const
{
  os << "substr()";
}

CAwkValuePtr
CAwkAtan2Function::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 2) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value1 = values[0]->getValue()->getReal();
  double value2 = values[1]->getValue()->getReal();

  double result = atan2(value1, value2);

  return CAwkValue::create(result);
}

void
CAwkAtan2Function::
print(std::ostream &os) const
{
  os << "atan2()";
}

CAwkValuePtr
CAwkCosFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = cos(value);

  return CAwkValue::create(result);
}

void
CAwkCosFunction::
print(std::ostream &os) const
{
  os << "cos()";
}

CAwkValuePtr
CAwkExpFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = exp(value);

  return CAwkValue::create(result);
}

void
CAwkExpFunction::
print(std::ostream &os) const
{
  os << "exp()";
}

CAwkValuePtr
CAwkIntFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = int(value);

  if (awk_->getDebug())
    std::cout << "int(" << value << ") = " << result << "\n";

  return CAwkValue::create(result);
}

void
CAwkIntFunction::
print(std::ostream &os) const
{
  os << "int()";
}

CAwkValuePtr
CAwkLogFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = log(value);

  return CAwkValue::create(result);
}

void
CAwkLogFunction::
print(std::ostream &os) const
{
  os << "log()";
}

CAwkValuePtr
CAwkRandFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 0) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double result = CMathRand::unitRand();

  return CAwkValue::create(result);
}

void
CAwkRandFunction::
print(std::ostream &os) const
{
  os << "rand()";
}

CAwkValuePtr
CAwkSinFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = sin(value);

  return CAwkValue::create(result);
}

void
CAwkSinFunction::
print(std::ostream &os) const
{
  os << "sin()";
}

CAwkValuePtr
CAwkSqrtFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  double value = values[0]->getValue()->getReal();

  double result = sqrt(value);

  return CAwkValue::create(result);
}

void
CAwkSqrtFunction::
print(std::ostream &os) const
{
  os << "sqrt()";
}

CAwkValuePtr
CAwkSrandFunction::
exec(const CAwkExpressionTermList &values)
{
  if (values.size() != 0 && values.size() != 1) {
    awk_->error("Invalid number of arguments");
    return CAwkValue::create("");
  }

  if (values.size() == 1) {
    double value = values[0]->getValue()->getReal();

    srand(int(value));
  }
  else
    srand(time(0));

  return CAwkValue::create("");
}

void
CAwkSrandFunction::
print(std::ostream &os) const
{
  os << "srand()";
}
##concat##CAwkOperator.cpp
#include <CAwk.h>
#include <CMathGen.h>

CAwkExpressionTermPtr
CAwkAssignOperator::
execute()
{
  auto value = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value.refCast<CAwkExpressionTerm>();
  }

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPlusEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if      (value1->isInteger() && value2->isInteger())
    value = CAwkValue::create(value1->getInteger() + value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    value = CAwkValue::create(value1->getReal   () + value2->getReal   ());
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkMinusEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if      (value1->isInteger() && value2->isInteger())
    value = CAwkValue::create(value1->getInteger() - value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    value = CAwkValue::create(value1->getReal   () - value2->getReal   ());
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkTimesEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if      (value1->isInteger() && value2->isInteger())
    value = CAwkValue::create(value1->getInteger() * value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    value = CAwkValue::create(value1->getReal   () * value2->getReal   ());
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkDivideEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if (value1->isReal() || value2->isReal())
    value = CAwkValue::create(value1->getReal() / value2->getReal());
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkModulusEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if      (value1->isInteger() && value2->isInteger())
    value = CAwkValue::create((int)
              CMathGen::modulus((long) value1->getInteger(),
                                (long) value2->getInteger()));
  else if (value1->isReal   () || value2->isReal   ())
    value = CAwkValue::create(
              CMathGen::modulus(value1->getReal   (),
                                value2->getReal   ()));
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPowerEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();

  auto var = CAwkInst->getExecuteStack().popVariableRef();

  if (! var) {
    CAwkInst->error("Lhs is not a variable");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  CAwkValuePtr value;

  if      (value1->isInteger() && value2->isInteger())
    value = CAwkValue::create(CMathGen::pow((long) value1->getInteger(),
                                        (long) value2->getInteger()));
  else if (value1->isReal   () || value2->isReal   ())
    value = CAwkValue::create(CMathGen::pow(value1->getReal   (),
                                        value2->getReal   ()));
  else
    value = CAwkValue::create("0");

  var->setValue(value);

  return var.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkQuestionOperator::
execute()
{
  assert(false);

  return CAwkExpressionTermPtr();
}

CAwkExpressionTermPtr
CAwkColonOperator::
execute()
{
  assert(false);

  return CAwkExpressionTermPtr();
}

CAwkExpressionTermPtr
CAwkLogicalOrOperator::
execute()
{
  bool bool2 = CAwkInst->getExecuteStack().popValue()->getBool();
  bool bool1 = CAwkInst->getExecuteStack().popValue()->getBool();

  auto result = CAwkValue::create(bool1 || bool2);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkLogicalAndOperator::
execute()
{
  bool bool2 = CAwkInst->getExecuteStack().popValue()->getBool();
  bool bool1 = CAwkInst->getExecuteStack().popValue()->getBool();

  auto result = CAwkValue::create(bool1 && bool2);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkInOperator::
execute()
{
  auto var = CAwkInst->getExecuteStack().popVariableRef();

  CAwkValuePtr result;

  if (! var) {
    CAwkInst->error("value is not a variable");

    result = CAwkValue::create("0");
  }
  else {
    std::string value = CAwkInst->getExecuteStack().popValue()->getString();

    bool flag = var->isInd(value);

    result = CAwkValue::create(flag);
  }

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkRegExpOperator::
execute()
{
  std::string value2 = CAwkInst->getExecuteStack().popValue()->getString();
  std::string value1 = CAwkInst->getExecuteStack().popValue()->getString();

  CRegExp regexp(value2);

  regexp.setExtended(true);

  bool match = regexp.find(value1);

  auto result = CAwkValue::create(match);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkNotRegExpOperator::
execute()
{
  std::string value2 = CAwkInst->getExecuteStack().popValue()->getString();
  std::string value1 = CAwkInst->getExecuteStack().popValue()->getString();

  CRegExp regexp(value2);

  regexp.setExtended(true);

  bool match = regexp.find(value1);

  auto result = CAwkValue::create(! match);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkLessOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) < 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkLessEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) <= 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) == 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkNotEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) != 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkGreaterEqualsOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) >= 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkGreaterOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  auto result = CAwkValue::create(value1->cmp(value2) > 0);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkConcatOperator::
execute()
{
  std::string str2 = CAwkInst->getExecuteStack().popValue()->getString();
  std::string str1 = CAwkInst->getExecuteStack().popValue()->getString();

  auto result = CAwkValue::create(str1 + str2);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPlusOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value1->isInteger() && value2->isInteger())
    result = CAwkValue::create(value1->getInteger() + value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    result = CAwkValue::create(value1->getReal   () + value2->getReal   ());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkMinusOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value1->isInteger() && value2->isInteger())
    result = CAwkValue::create(value1->getInteger() - value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    result = CAwkValue::create(value1->getReal   () - value2->getReal   ());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkTimesOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value1->isInteger() && value2->isInteger())
    result = CAwkValue::create(value1->getInteger() * value2->getInteger());
  else if (value1->isReal   () || value2->isReal   ())
    result = CAwkValue::create(value1->getReal   () * value2->getReal   ());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkDivideOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if (value1->isReal() || value2->isReal())
    result = CAwkValue::create(value1->getReal() / value2->getReal());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkModulusOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value1->isInteger() && value2->isInteger())
    result = CAwkValue::create((int)
               CMathGen::modulus((long) value1->getInteger(),
                                 (long) value2->getInteger()));
  else if (value1->isReal   () || value2->isReal   ())
    result = CAwkValue::create(
               CMathGen::modulus(value1->getReal   (),
                                 value2->getReal   ()));
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkUnaryPlusOperator::
execute()
{
  auto value = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value->isInteger())
    result = CAwkValue::create(value->getInteger());
  else if (value->isReal())
    result = CAwkValue::create(value->getReal());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkUnaryMinusOperator::
execute()
{
  auto value = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value->isInteger())
    result = CAwkValue::create(-value->getInteger());
  else if (value->isReal())
    result = CAwkValue::create(-value->getReal());
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkLogicalNotOperator::
execute()
{
  bool bool1 = CAwkInst->getExecuteStack().popValue()->getBool();

  auto result = CAwkValue::create(! bool1);

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPowerOperator::
execute()
{
  auto value2 = CAwkInst->getExecuteStack().popValue();
  auto value1 = CAwkInst->getExecuteStack().popValue();

  CAwkValuePtr result;

  if      (value1->isInteger() && value2->isInteger())
    result = CAwkValue::create(CMathGen::pow((long) value1->getInteger(),
                                                  (long) value2->getInteger()));
  else if (value1->isReal   () || value2->isReal   ())
    result = CAwkValue::create(CMathGen::pow(value1->getReal   (),
                                                  value2->getReal   ()));
  else
    result = CAwkValue::create("0");

  return result.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPreIncrementOperator::
execute()
{
  auto var = CAwkInst->getExecuteStack().popVariableRef();

  CAwkValuePtr value2;

  if (! var) {
    CAwkInst->error("value is not a variable");
    value2 = CAwkValue::create("0");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  if      (value1->isInteger())
    value2 = CAwkValue::create(value1->getInteger() + 1);
  else if (value1->isReal   ())
    value2 = CAwkValue::create(value1->getReal   () + 1);
  else
    value2 = CAwkValue::create("1");

  var->setValue(value2);

  return value2.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPostIncrementOperator::
execute()
{
  auto var = CAwkInst->getExecuteStack().popVariableRef();

  CAwkValuePtr value2;

  if (! var) {
    CAwkInst->error("value is not a variable");
    value2 = CAwkValue::create("0");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  if      (value1->isInteger()) {
    value1 = CAwkValue::create(value1->getInteger());
    value2 = CAwkValue::create(value1->getInteger() + 1);
  }
  else if (value1->isReal   ()) {
    value1 = CAwkValue::create(value1->getReal   ());
    value2 = CAwkValue::create(value1->getReal   () + 1);
  }
  else {
    value1 = CAwkValue::create("0");
    value2 = CAwkValue::create("1");
  }

  var->setValue(value2);

  return value1.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPreDecrementOperator::
execute()
{
  auto var = CAwkInst->getExecuteStack().popVariableRef();

  CAwkValuePtr value2;

  if (! var) {
    CAwkInst->error("value is not a variable");
    value2 = CAwkValue::create("0");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  if      (value1->isInteger())
    value2 = CAwkValue::create(value1->getInteger() - 1);
  else if (value1->isReal   ())
    value2 = CAwkValue::create(value1->getReal   () - 1);
  else
    value2 = CAwkValue::create("-1");

  var->setValue(value2);

  return value2.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkPostDecrementOperator::
execute()
{
  auto var = CAwkInst->getExecuteStack().popVariableRef();

  CAwkValuePtr value2;

  if (! var) {
    CAwkInst->error("value is not a variable");
    value2 = CAwkValue::create("0");
    return value2.refCast<CAwkExpressionTerm>();
  }

  auto value1 = var->getValue();

  if      (value1->isInteger()) {
    value1 = CAwkValue::create(value1->getInteger());
    value2 = CAwkValue::create(value1->getInteger() - 1);
  }
  else if (value1->isReal   ()) {
    value1 = CAwkValue::create(value1->getReal   ());
    value2 = CAwkValue::create(value1->getReal   () - 1);
  }
  else {
    value1 = CAwkValue::create("0");
    value2 = CAwkValue::create("-1");
  }

  var->setValue(value2);

  return value1.refCast<CAwkExpressionTerm>();
}

CAwkExpressionTermPtr
CAwkFieldOperator::
execute()
{
  auto value = CAwkInst->getExecuteStack().popValue();

  CAwkVariableRefPtr result;

  if (value->isInteger()) {
    int pos = value->getInteger();

    result = CAwkFieldVariableRef::create(pos);
  }
  else
    result = CAwkVariableRef::create(value->getString());

  return result.refCast<CAwkExpressionTerm>();
}
##concat##CAwkPattern.cpp
#include <CAwk.h>

bool
CAwkRegExpPattern::
exec()
{
  std::string str = CAwkInst->getLineField(0);

  return regexp_.find(str);
}

void
CAwkRegExpPattern::
print(std::ostream &os) const
{
  os << "/" << regexp_.getPattern() << "/";
}

bool
CAwkNegatePattern::
exec()
{
  return ! pattern_->exec();
}

void
CAwkNegatePattern::
print(std::ostream &os) const
{
  os << "!" << *pattern_;
}

bool
CAwkExpressionPattern::
exec()
{
  auto value = expression_->getValue();

  return value->getBool();
}

void
CAwkExpressionPattern::
print(std::ostream &os) const
{
  os << *expression_;
}

bool
CAwkBeginPattern::
exec()
{
  return true;
}

bool
CAwkEndPattern::
exec()
{
  return true;
}

bool
CAwkCompositeOrPattern::
exec()
{
  return (pattern1_->exec() || pattern2_->exec());
}

void
CAwkCompositeOrPattern::
print(std::ostream &os) const
{
  os << *pattern1_ << " || " << *pattern2_;
}

bool
CAwkCompositeAndPattern::
exec()
{
  return (pattern1_->exec() && pattern2_->exec());
}

void
CAwkCompositeAndPattern::
print(std::ostream &os) const
{
  os << *pattern1_ << " && " << *pattern2_;
}

bool
CAwkRangePattern::
exec()
{
  if      (state_ == START_STATE) {
    if (pattern1_->exec()) {
      state_ = END_STATE;
      return true;
    }

    return false;
  }
  else if (state_ == END_STATE) {
    if (pattern2_->exec()) {
      state_ = DONE_STATE;
      return true;
    }

    return true;
  }
  else
    return false;
}

void
CAwkRangePattern::
print(std::ostream &os) const
{
  os << *pattern1_ << " , " << *pattern2_;
}
##concat##CAwkValue.cpp
#include <CAwk.h>
#include <CStrUtil.h>

CAwkValuePtr
CAwkValue::
create(const std::string &value)
{
  return CAwkValuePtr(new CAwkValue(value));
}

CAwkValuePtr
CAwkValue::
create(const char *value)
{
  return CAwkValuePtr(new CAwkValue(value));
}

CAwkValuePtr
CAwkValue::
create(double value)
{
  return CAwkValuePtr(new CAwkValue(value));
}

CAwkValuePtr
CAwkValue::
create(int value)
{
  return CAwkValuePtr(new CAwkValue(value));
}

CAwkValuePtr
CAwkValue::
create(bool value)
{
  return CAwkValuePtr(new CAwkValue(value));
}

//-------------

CAwkValue::
CAwkValue(const std::string &value) :
 value_(value)
{
}

CAwkValue::
CAwkValue(const char *value) :
 value_(value)
{
}

CAwkValue::
CAwkValue(double value) :
 value_(CStrUtil::toString(value))
{
}

CAwkValue::
CAwkValue(int value) :
 value_(CStrUtil::toString(value))
{
}

CAwkValue::
CAwkValue(bool value) :
 value_(value ? "1" : "0")
{
}

bool
CAwkValue::
isReal() const
{
  return CStrUtil::isReal(value_);
}

bool
CAwkValue::
isInteger() const
{
  return CStrUtil::isInteger(value_);
}

bool
CAwkValue::
isBool() const
{
  return (value_ == "1" || value_ == "0");
}

std::string
CAwkValue::
getString() const
{
  return value_;
}

double
CAwkValue::
getReal() const
{
  if      (CStrUtil::isReal(value_))
    return CStrUtil::toReal(value_);
  else if (CStrUtil::isInteger(value_))
    return CStrUtil::toInteger(value_);
  else
    return 0.0;
}

int
CAwkValue::
getInteger() const
{
  if      (CStrUtil::isInteger(value_))
    return CStrUtil::toInteger(value_);
  else if (CStrUtil::isReal(value_))
    return int(CStrUtil::toReal(value_));
  else
    return 0;
}

bool
CAwkValue::
getBool() const
{
  return (value_ != "" && value_ != "0");
}

void
CAwkValue::
setValue(CAwkValuePtr value)
{
  value_ = value->value_;
}

void
CAwkValue::
setString(const std::string &value)
{
  value_ = value;
}

void
CAwkValue::
setReal(double value)
{
  value_ = CStrUtil::toString(value);
}

void
CAwkValue::
setInteger(int value)
{
  value_ = CStrUtil::toString(value);
}

void
CAwkValue::
setBool(bool value)
{
  value_ = (value ? "1" : "0");
}

int
CAwkValue::
cmp(CAwkValuePtr rhs) const
{
  if      ((     isReal() && (rhs->isReal() || rhs->isInteger())) ||
           (rhs->isReal() && (     isReal() ||      isInteger()))) {
    double real1 =      getReal();
    double real2 = rhs->getReal();

    if      (real1 >  real2) return  1;
    else if (real1 <  real2) return -1;
    else                     return  0;
  }
  else if (isInteger() && rhs->isInteger()) {
    double integer1 =      getInteger();
    double integer2 = rhs->getInteger();

    if      (integer1 > integer2) return  1;
    else if (integer1 < integer2) return -1;
    else                          return  0;
  }
  else if (isBool   () && rhs->isBool   ()) {
    bool bool1 =      getBool();
    bool bool2 = rhs->getBool();

    if      (bool1 >  bool2) return  1;
    else if (bool1 <  bool2) return -1;
    else                     return  0;
  }
  else {
    std::string str1 =      getString();
    std::string str2 = rhs->getString();

    if      (str1 >  str2) return  1;
    else if (str1 <  str2) return -1;
    else                   return  0;
  }
}

void
CAwkValue::
print(std::ostream &os) const
{
  if      (isReal())
    os << getReal();
  else if (isInteger())
    os << getInteger();
  else if (isBool())
    os << (getBool() ? "1" : "0");
  else
    os << "\"" << value_ << "\"";
}
##concat##CAwkVariable.cpp
#include <CAwk.h>
#include <CFuncs.h>

void
CAwkVariableMgr::
addVariable(const std::string &name, const std::string &value)
{
  addVariable(CAwkVariable::create(name, value));
}

void
CAwkVariableMgr::
addVariable(CAwkVariablePtr var)
{
  variableMap_[var->getName()] = var;
}

CAwkVariablePtr
CAwkVariableMgr::
getVariable(const std::string &name) const
{
  auto p = variableMap_.find(name);

  if (p != variableMap_.end())
    return p->second;

  return CAwkVariablePtr();
}

void
CAwkVariableMgr::
print(std::ostream &os) const
{
  CPrintSeparated<CAwkVariable> ps(os);

  for (const auto &v : variableMap_)
    ps(v.second.get());
}

//-------------

CAwkVariablePtr
CAwkVariable::
create(const std::string &name, const std::string &value)
{
  return CAwkVariablePtr(new CAwkVariable(name, value));
}

CAwkVariablePtr
CAwkVariable::
create(const std::string &name, const char *value)
{
  return CAwkVariablePtr(new CAwkVariable(name, value));
}

CAwkVariablePtr
CAwkVariable::
create(const std::string &name, double value)
{
  return CAwkVariablePtr(new CAwkVariable(name, value));
}

CAwkVariablePtr
CAwkVariable::
create(const std::string &name, int value)
{
  return CAwkVariablePtr(new CAwkVariable(name, value));
}

CAwkVariablePtr
CAwkVariable::
create(const std::string &name, bool value)
{
  return CAwkVariablePtr(new CAwkVariable(name, value));
}

//-------------

CAwkVariable::
CAwkVariable(const std::string &name, const char *value) :
 name_(name)
{
  value_ = CAwkValue::create(value);
}

CAwkVariable::
CAwkVariable(const std::string &name, const std::string &value) :
 name_(name)
{
  value_ = CAwkValue::create(value);
}

CAwkVariable::
CAwkVariable(const std::string &name, double value) :
 name_(name)
{
  value_ = CAwkValue::create(value);
}

CAwkVariable::
CAwkVariable(const std::string &name, int value) :
 name_(name)
{
  value_ = CAwkValue::create(value);
}

CAwkVariable::
CAwkVariable(const std::string &name, bool value) :
 name_(name)
{
  value_ = CAwkValue::create(value);
}

CAwkValuePtr
CAwkVariable::
getValue() const
{
  return value_;
}

CAwkValuePtr
CAwkVariable::
getIndValue(const std::string &ind) const
{
  auto p = indValueMap_.find(ind);

  if (p != indValueMap_.end())
    return p->second;

  auto value = CAwkValue::create("");

  auto *th = const_cast<CAwkVariable *>(this);

  th->indValueMap_[ind] = value;

  return value;
}

void
CAwkVariable::
setValue(CAwkValuePtr value)
{
  value_ = value;

  value_.uniquify();
}

void
CAwkVariable::
setIndValue(const std::string &ind, CAwkValuePtr value)
{
  auto p = indValueMap_.find(ind);

  if (p != indValueMap_.end()) {
    p->second = value;
    return;
  }

  indValueMap_[ind] = value;
}

bool
CAwkVariable::
isInd(const std::string &ind) const
{
  auto p = indValueMap_.find(ind);

  return (p != indValueMap_.end());
}

void
CAwkVariable::
removeInd(const std::string &ind)
{
  auto p = indValueMap_.find(ind);

  indValueMap_.erase(p);
}

StringVectorT
CAwkVariable::
getIndices() const
{
  StringVectorT indices;

  for (const auto &pi : indValueMap_)
    indices.push_back(pi.first);

  //std::sort(indices.begin(), indices.end());

  return indices;
}

CAwkExpressionTermPtr
CAwkVariable::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}

void
CAwkVariable::
print(std::ostream &os) const
{
  os << name_ << "=" << *value_;
}

//-----------

void
CAwkVariableRef::
instantiate(bool global)
{
  (void) CAwkInst->getVariable(name_, /*create*/true, global);
}

CAwkValuePtr
CAwkVariableRef::
getValue() const
{
  return CAwkInst->getVariable(name_, true)->getValue();
}

void
CAwkVariableRef::
setValue(CAwkValuePtr value)
{
  CAwkInst->getVariable(name_, true)->setValue(value);
}

bool
CAwkVariableRef::
isInd(const std::string &ind) const
{
  // TODO: create ?
  return CAwkInst->getVariable(name_, true)->isInd(ind);
}

void
CAwkVariableRef::
removeInd(const std::string &ind)
{
  // TODO: create ?
  return CAwkInst->getVariable(name_, true)->removeInd(ind);
}

CAwkValuePtr
CAwkVariableRef::
getIndValue(const std::string &ind) const
{
  // TODO: create ?
  return CAwkInst->getVariable(name_, true)->getIndValue(ind);
}

void
CAwkVariableRef::
setIndValue(const std::string &ind, CAwkValuePtr value)
{
  CAwkInst->getVariable(name_, true)->setIndValue(ind, value);
}

StringVectorT
CAwkVariableRef::
getIndices() const
{
  // TODO: create ?
  return CAwkInst->getVariable(name_, true)->getIndices();
}

CAwkExpressionTermPtr
CAwkVariableRef::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}

void
CAwkVariableRef::
print(std::ostream &os) const
{
  os << "&" << name_;
}

//-----------

CAwkValuePtr
CAwkArrayVariableRef::
getValue() const
{
  std::string ind = getInd();

  return CAwkVariableRef::getIndValue(ind);
}

void
CAwkArrayVariableRef::
setValue(CAwkValuePtr value)
{
  std::string ind = getInd();

  CAwkVariableRef::setIndValue(ind, value);
}

CAwkExpressionTermPtr
CAwkArrayVariableRef::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}

void
CAwkArrayVariableRef::
print(std::ostream &os) const
{
  CAwkVariableRef::print(os);

  os << "[";

  int i = 0;

  for (auto &expr : expressionList_) {
    if (i > 0)
      os << ",";

    os << *expr;

    ++i;
  }

  os << "]";
}

std::string
CAwkArrayVariableRef::
getInd() const
{
  std::string ind;

  int i = 0;

  for (auto &expr : expressionList_) {
    if (i > 0)
      ind += CAwkInst->getVariable("SUBSEP")->getValue()->getString();

    ind += expr->getValue()->getString();

    ++i;
  }

  return ind;
}

//-----------

CAwkValuePtr
CAwkFieldVariableRef::
getValue() const
{
  return CAwkValue::create(CAwkInst->getLineField(pos_));
}

void
CAwkFieldVariableRef::
setValue(CAwkValuePtr value)
{
  CAwkInst->setLineField(pos_, value->getString());
}

void
CAwkFieldVariableRef::
print(std::ostream &os) const
{
  os << "$" << pos_;
}

CAwkExpressionTermPtr
CAwkFieldVariableRef::
execute()
{
  return getValue().refCast<CAwkExpressionTerm>();
}
